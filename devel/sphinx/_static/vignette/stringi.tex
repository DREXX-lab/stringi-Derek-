% makeme:
%     build: xelatex_nobibtex

%!TEX program = XeLaTeX
%!Rnw weave = Sweave

\newif\ifnotJSSversion
%%%%%% TODO: \notJSSversionfalse == JSS version :) == fewer examples
\notJSSversionfalse




\documentclass[nojss]{jss}
% \documentclass[article]{jss}
\usepackage[]{graphicx}\usepackage[]{color}
% maxwidth is the original width if it is less than linewidth
% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\usepackage{Sweave}


\usepackage{xltxtra}

\usepackage{thumbpdf,lmodern,xcolor}
% \usepackage{framed}
% \usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
% \usepackage{CJKutf8}
\usepackage{amsmath,amssymb}
\usepackage{booktabs}
\usepackage{verbatim}
\usepackage{tabularx}
% \usepackage[UTF8]{ctex}
\usepackage{xeCJK}
\usepackage{fontspec}
\usepackage{wasysym}
\setCJKmainfont{Noto Sans Mono CJK SC}
\setCJKsansfont{Noto Sans Mono CJK SC}
\setCJKmonofont{Noto Sans Mono CJK SC}
\usepackage{tipa}
% \usepackage{lmodern}
% \setmonofont{Latin Modern Mono}
% \setmonofont{Ubuntu Mono}%[Scale=0.85]
% \usepackage{alphabeta}



%% For Sweave-based articles about R packages:
%% need no \usepackage{Sweave}
%\usepackage{Sweave}
%\SweaveOpts{engine=R, eps=FALSE, keep.source = TRUE}





\author{Marek Gagolewski\\
Deakin University, Geelong, VIC 3220, Australia\\
Systems Research Institute, Polish Academy of Sciences
}
\Plainauthor{Marek Gagolewski}

%% - \title{} in title case
%% - \Plaintitle{} without LaTeX markup (if any)
%% - \Shorttitle{} with LaTeX markup (if any), used as running title
\title{\pkg{stringi}: Fast and Portable\\Character String
Processing in \proglang{R}}
\Plaintitle{stringi: Fast and Portable Character String Processing in R}
\Shorttitle{\pkg{stringi}: Fast and Portable Character String Processing
in \proglang{R}}

% \title in title style,
% all titles in the BibTeX file in title style.
% \section, \subsection, etc. in sentence style,



%% - \Abstract{} almost as usual
\Abstract{
Effective processing of character strings is required at various
stages of data analysis pipelines:
from data cleansing and preparation, through
information extraction, to report generation.
Pattern searching, string collation and sorting, normalisation,
transliteration, and formatting are ubiquitous in
text mining, natural language processing, and bioinformatics.
This paper discusses and demonstrates how and why \pkg{stringi},
a mature \proglang{R} package for fast and portable handling of string data
based on the \pkg{ICU} library (International Components for Unicode),
should be included in each statistician's or data scientist's
repertoire to complement their  numerical computing
and data wrangling skills.
}

%% - \Keywords{} with LaTeX markup, at least one required
%% - \Plainkeywords{} without LaTeX markup (if necessary)
%% - Should be comma-separated and in sentence case.
\Keywords{\pkg{stringi}, character strings, text, \pkg{ICU}, Unicode,
regular expressions, data cleansing, natural language processing,
\proglang{R}}
\Plainkeywords{stringi, character strings, text, ICU, Unicode, regular
expressions, data cleansing, natural language processing, R}

\Address{
  \textbf{Marek Gagolewski}\\
  School of Information Technology\\
  Deakin University\\
  Geelong, VIC 3220, Australia\\
  \emph{and}\\
  Systems Research Institute\\
  Polish Academy of Sciences\\
  ul.~Newelska 6, 01-447 Warsaw, Poland\\
  E-mail: \email{m.gagolewski@deakin.edu.au}\\
  URL: \url{https://www.gagolewski.com/}
}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}


{\color{blue}
This is a draft version of a paper on \pkg{stringi}, last updated on \today.

Please cite as:
Gagolewski M (2021).
\textit{\pkg{stringi}: Fast and Portable Character String Processing in \proglang{R}}.
URL \url{https://stringi.gagolewski.com}.
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{Sec:intro}

Stringology \citep{stringology} deals with algorithms and data structures
for character string processing \citep{speechlangproc,szpankowski}.
From the perspective of applied statistics and data science,
it is worth stressing that many interesting data sets
first come in unstructured or contaminated textual forms,
for instance when they have been fetched from different APIs or gathered
by means of web scraping techniques.

Diverse data cleansing and preparation operations
(\citealp{datacleaning,cleanr}; see also
Section~\ref{Sec:examples} below for a real-world example)
need to be applied before an analyst can begin to enjoy
an orderly and meaningful data frame, matrix, or spreadsheet being finally
at their disposal.
Activities related to information retrieval, computer vision,
bioinformatics, natural language processing, or even musicology
can also benefit from including them
in data processing pipelines \citep{speechlangproc,genome}.
% This includes string concatenation,
% substring extraction, collation, sorting, Unicode normalisation,
% transliteration, pattern matching, and date-time parsing.


% sentiment of emojis 10.1371/journal.pone.0144296
Although statisticians and data analysts are usually
very proficient in numerical computing and data wrangling,
the awareness of how crucial text operations are in the generic
data-oriented skill-set is yet to reach a more operational
level. This paper aims to fill this gap.

\bigskip
Most statistical computing ecosystems provide only a basic set of text
operations. In particular, base \proglang{R} \citep{Rproject:home}
is mostly restricted to pattern matching, string concatenation,
substring extraction, trimming, padding, wrapping,
simple character case conversion, and string collation,
see \citep[Chapter~8]{Chambers2008:SoftDA} and Table~\ref{Tab:oldstringr} below.
The \pkg{stringr} package \citep{Wickham2010:stringr},
first released in November 2009, implemented an alternative, ``tidy''
API for text data processing (cleaned-up function names,
more beginner-friendly outputs, etc.;
the list of 21 functions that were available in \pkg{stringr} at that
time is given in Table~\ref{Tab:oldstringr}).
The early \pkg{stringr} featured a few wrappers around
a subset of its base \proglang{R} counterparts. The latter,
however -- to this day -- not only is of limited scope,
but also suffers from a number of portability issues; it may happen that
the same code can yield different results on different operating systems;
see Section~\ref{Sec:design} for some examples.


% In version 0.6.2 (dated 2012--12--06)
% of \pkg{stringr}'s \code{README}, we read that this package:
% \begin{quote}\it
% \begin{itemize}
% \item processes factors and characters in the same way,
% \item gives functions consistent names and arguments,
% \item simplifies string operations by eliminating options that you
% don't need 95\% of the time,
% \item produces outputs than can easily be used as inputs.
% This includes ensuring that missing inputs result in missing outputs,
% and zero length inputs result in zero length outputs,
% \item completes \proglang{R}'s string handling functions with
% useful functions from other programming languages.
% % and duplicates existing API :/
% \end{itemize}
% \end{quote}

In order to significantly broaden the array of string processing
operations and assure that they are portable, in 2013 the current
author developed the open source \pkg{stringi} package
(pronounced ``stringy'', IPA \textipa{[{stringi}]}).
Its API was compatible with that of early \pkg{stringr}'s,
which some users found convenient. However, for the processing of text
in different locales, which are plentiful, \pkg{stringi} relies
on \pkg{ICU} -- International Components for Unicode
(see \url{http://site.icu-project.org/}) -- a mature library that
fully conforms with the Unicode standard and which provides globalisation
support for a broad range of other software applications as well, from
web browsers to database systems. Services not covered by \pkg{ICU}
were implemented from scratch to guarantee that they are as efficient
as possible.

Over the years, \pkg{stringi} confirmed itself as robust,
production-quality software; for many years now it has been one of the
most often downloaded R extensions. Interestingly, in 2015 the
aforementioned \pkg{stringr} package has been rewritten as a
set of wrappers around some of the \pkg{stringi} functions instead of
the base \proglang{R} ones.
% \pkg{stringr} currently exports length(ls("package:stringr")) objects
In Section~14.7 of \textit{R for Data Science}
\citep{GrolemundWickham2017:rdatascience}
we read: \textit{\pkg{stringr} is useful when you're learning because
it exposes a minimal set of functions, which have been carefully picked
to handle the most common string manipulation functions. \pkg{stringi},
on the other hand, is designed to be comprehensive. It contains almost
every function you might ever need: \pkg{stringi} has 250 functions to
\pkg{stringr}'s 49}.
Also, it is worth noting that the recently-introduced \pkg{stringx}
package \citep{stringx} supplies a \pkg{stringi}-based set of portable
and efficient replacements for and enhancements of the base \code{R}
functions.

% > sum(stri_detect(ls(envir=environment(str_detect)), regex="^str_"))  # v0.6.2
% [1] 21
% > sum(stri_detect(ls(envir=environment(str_detect)), regex="^str_"))  # v1.4.0
% [1] 45
% > sum(stri_detect(ls(envir=environment(stri_detect)), regex="^stri_"))
% [1] 242

% On the other hand, \pkg{stringi} provides many more
% functions (length(ls("package:stringi"))
% vs~length(ls("package:stringr"))); some of them are
% more specialised or equipped with more control parameters
% to enable fine-tuning.

\bigskip
This paper describes the most noteworthy facilities provided by
\pkg{stringi} that statisticians and data analysts may find
useful in their daily activities. We demonstrate how important it is
for a modern data scientist to be aware of the challenges
of natural language processing in the internet era:
how to force \code{"groß"} compare equal to \code{"GROSS"},
count the number of occurrences of \code{"AGA"} within
\code{"ACTGAGAGACGGGTTAGAGACT"},
make \code{"a13"} ordered before \code{"a100"}, or
convert between \code{"GRINNING FACE"} and \code{"\smiley"} forth and back.
Such operations are performed by the very \pkg{ICU} itself;
we therefore believe that what follows may be of interest
to data-oriented practitioners employing Python, Perl, Julia, PHP, etc.,
as \pkg{ICU} has bindings for many other languages.


Here is the outline of the paper:
\begin{itemize}
\item Section~\ref{Sec:examples} illustrates the importance of string
processing in an example data preparation activity.

\item General package design principles are outlined in
Section~\ref{Sec:design}, including the use cases of deep vectorisation,
the concepts of data flow,
and the main deviations from base \proglang{R}
(also with regards to portability and speed).

\item Basic string operations, such as computing length and width
of strings, string concatenation, extracting and replacing substrings,
are discussed in Section~\ref{Sec:basic}.

\item Section~\ref{Sec:fixed} discusses searching for fixed substrings:
counting the number of matches, locating their positions,
replacing them with other data, and splitting strings into tokens.
% detecting, extracting

\item Section~\ref{Sec:regex} details \pkg{ICU} regular
expressions, which are a powerful tool for matching patterns defined in
a more abstract way, e.g., extracting numbers from text so that they can
be processed quantitatively, identifying hyperlinks, etc.
We show where \pkg{ICU} is different from other libraries like \pkg{PCRE};
in particular that it enables portable, Unicode-correct look-ups,
for instance, involving sequences of emojis or mathematical symbols.

\item Section~\ref{Sec:collator} deals with the locale-aware \pkg{ICU}
Collator, which is  suitable for natural language processing activities;
this is where we demonstrate that text processing in different languages
or regions is governed by quite diverse rules,
deviating significantly from the US-ASCII (``C/POSIX.1'') setting.
The operations discussed therein include testing string equivalence (which can
turn out useful when we scrape data that consist of non-normalised strings,
ignorable punctuation, or accented characters) as well as arranging strings
with regards to different linear orderings.

\item Section~\ref{Sec:other} covers some other useful operations such
as text boundary analysis (for splitting text into words or sentences),
trimming, padding, and other formatting, random string generation,
character transliteration (converting between cases and alphabets,
removing diacritic marks, etc.) as well as date-time formatting and
parsing in any locale (e.g., Japanese dates in a German \proglang{R}).

\item Section~\ref{Sec:io} details on encoding conversion and detection
(which is key when reading or writing text files that are to be communicated
across different systems) as well as Unicode normalisation
(which can be useful for removing formatting
distinctions from text, e.g., superscripts or font variants).

\item Finally, Section~\ref{Sec:conclusions} concludes the paper.
\end{itemize}



This paper is by no means a substitute for the comprehensive yet much
more technical and in-depth reference manual available via a call to
\code{help(package="stringi")}, see also
\url{https://stringi.gagolewski.com/}. Rather, below we explain
the package's key design principles and broadly introduce the ideas and
services that help program, correct, and optimise text processing workflows.

Let us emphasise that all the below-presented illustrations,
i.e., calls to \pkg{stringi} functions on different
example arguments together with the generated outputs, form an integral
part of this manuscript's text. They have been included based on
the author's experience-based belief that each "picture" (that we print
out below using a monospaced font) is worth hundreds of words.

% confirmed itself as robust,  production quality software
% yet, new features being added $\sim$ biyearly








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\medskip
All code chunk outputs presented in this paper were obtained in
\proglang{R}~4.1.0.
The \proglang{R} environment itself and all the packages used herein
are available from CRAN at \url{https://CRAN.R-project.org/}.
In particular, \code{install.packages("stringi")} can be called to
fetch the object of our focus.
%Moreover, for \pkg{stringr}~packageVersion("stringr")
By calling:

%%% # R CMD INSTALL stringi --preclean --configure-args='--disable-pkg-config'

\begin{Schunk}
\begin{Sinput}
R> library("stringi")
R> cat(stri_info(short=TRUE))
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Soutput}
stringi_1.7.3 (en_AU.UTF-8; ICU4C 69.1 [bundle]; Unicode 13.0)
\end{Soutput}
\end{Schunk}


\noindent
we can load and attach the package's namespace
and display some basic information thereon.
Hence, below we shall be working with
\pkg{stringi} 1.7.3, however, as the package
API is considered stable, the presented material should be relevant to
any later versions.
% which has been built against the following version of the \pkg{ICU}
% library and which uses the following



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Use case: Data preparation}\label{Sec:examples}

Before going into details on the broad array of facilities offered by the
\pkg{stringi} package itself,
let us first demonstrate that string processing is indeed a relevant
part of statistical data analysis workflows.
What follows is a short case study where we prepare a web-scraped
data set for further processing.

Assume we wish to gather and analyse
climate data for major cities around the world based on information
downloaded from \textit{Wikipedia}.
For each location from a given list of settlements (e.g.,
fetched from one of the pages linked under
\url{https://en.wikipedia.org/wiki/Lists_of_cities}),
we would like to harvest the relevant temperature and precipitation data.
Without harm in generality, let us focus on the city of Melbourne,
VIC, Australia.

The parsing of the city's~\textit{Wikipedia} page
can be done by means of the functions from the
\pkg{xml2} \citep{xml2}
and \pkg{rvest} \citep{rvest} packages.

\begin{Schunk}
\begin{Sinput}
R> library("xml2")
R> library("rvest")
\end{Sinput}
\end{Schunk}

First, let us load and parse the \proglang{HTML} file
downloaded on 2020--09--17 (see the accompanying supplementary files):

\begin{Schunk}
\begin{Sinput}
R> f <- read_html("20200917_wikipedia_melbourne.html")
\end{Sinput}
\end{Schunk}

Second, we extract all \code{table} elements and gather them
in a list of \proglang{HTML} nodes, \code{all\_tables}.
We then extract the underlying raw text data and store them in a
character vector named \code{text\_tables}.

\begin{Schunk}
\begin{Sinput}
R> all_tables <- html_nodes(f, "table")
R> text_tables <- sapply(all_tables, html_text)
R> str(text_tables, nchar.max=65, vec.len=5, strict.width="wrap") # preview
\end{Sinput}
\begin{Soutput}
chr [1:45] "MelbourneVictoriaFrom top, left to right: Flinde"| __truncated__
   "Mean max temp\n Mean min temp\n Annual rainfal"| __truncated__ "This
   section needs additional citations for veri"| __truncated__ "Climate data
   for Melbourne Regional Office (1991"| __truncated__ "Country of Birth
   (2016)[178]Birthplace[N 1]\nPop"| __truncated__ ...
\end{Soutput}
\end{Schunk}

Most~\textit{Wikipedia} pages related to particular cities
include a table labelled as ``Climate data''.
We need to pinpoint it amongst all the other tables.
For this, we will rely on \pkg{stringi}'s
\code{stri_detect_fixed()} function that, in the configuration
below, is used to extract the index of the relevant table.

\begin{Schunk}
\begin{Sinput}
R> library("stringi")
R> (idx <- which(stri_detect_fixed(text_tables, "climate data",
+    case_insensitive=TRUE, max_count=1)))
\end{Sinput}
\begin{Soutput}
[1] 4
\end{Soutput}
\end{Schunk}

Of course, the detailed description of all the facilities
brought by \pkg{stringi} is covered below.
In the meantime, let us use \pkg{rvest}'s \code{html\_table()}
to convert the above table to a data frame object.


\begin{Schunk}
\begin{Sinput}
R> (x <- as.data.frame(html_table(all_tables[[idx]], fill=TRUE)))
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Soutput}
   Climate data for Melbourne Regional Office (1991–2015)
1                                                   Month
2                                     Record high °C (°F)
3                                    Average high °C (°F)
4                                      Daily mean °C (°F)
5                                     Average low °C (°F)
6                                      Record low °C (°F)
7                            Average rainfall mm (inches)
8                              Average rainy days (≥ 1mm)
9                 Average afternoon relative humidity (%)
10                            Mean monthly sunshine hours
11             Source: Bureau of Meteorology.[85][86][87]
   Climate data for Melbourne Regional Office (1991–2015).1 ...
1                                                       Jan ...
2                                               45.6(114.1) ...
3                                                27.0(80.6) ...
4                                                21.6(70.9) ...
5                                                16.1(61.0) ...
6                                                 5.5(41.9) ...
7                                                44.2(1.74) ...
8                                                       5.6 ...
9                                                        47 ...
10                                                      279 ...
11               Source: Bureau of Meteorology.[85][86][87] ...
   Climate data for Melbourne Regional Office (1991–2015).3
1                                                      Year
2                                               46.4(115.5)
3                                                20.8(69.4)
4                                                16.2(61.2)
5                                                11.6(52.9)
6                                                −2.8(27.0)
7                                              600.9(23.66)
8                                                      90.6
9                                                        51
10                                                    2,191
11               Source: Bureau of Meteorology.[85][86][87]
\end{Soutput}
\end{Schunk}

It is evident that this object requires some significant cleansing
and transforming before it can be subject to any statistical analyses.
First, for the sake of convenience, let us convert it to a character
matrix so that the processing of all the cells can be vectorised
(a matrix in \proglang{R} is just a single ``long'' vector,
whereas a data frame is a list of many atomic vectors).

\begin{Schunk}
\begin{Sinput}
R> x <- as.matrix(x)
\end{Sinput}
\end{Schunk}

The \code{as.numeric()} function will find the parsing of
the Unicode MINUS SIGN (U+2212, ``−'') difficult,
therefore let us call the transliterator first in order to replace it
(and other potentially problematic characters) with its simpler equivalent:

\begin{Schunk}
\begin{Sinput}
R> x[, ] <- stri_trans_general(x, "Publishing-Any; Any-ASCII")
\end{Sinput}
\end{Schunk}

Note that it is the first row of the matrix that defines the column names.
Moreover, the last row just gives the data source and hence may be removed.

\begin{Schunk}
\begin{Sinput}
R> dimnames(x) <- list(x[, 1], x[1, ])  # row, column names
R> x <- x[2:(nrow(x)-1), 2:ncol(x)]     # skip 1st/last row and 1st column
R> x[, c(1, ncol(x))]  # example columns
\end{Sinput}
\begin{Soutput}
                                        Jan           Year
Record high °C (°F)                     "45.6(114.1)" "46.4(115.5)"
Average high °C (°F)                    "27.0(80.6)"  "20.8(69.4)"
Daily mean °C (°F)                      "21.6(70.9)"  "16.2(61.2)"
Average low °C (°F)                     "16.1(61.0)"  "11.6(52.9)"
Record low °C (°F)                      "5.5(41.9)"   "-2.8(27.0)"
Average rainfall mm (inches)            "44.2(1.74)"  "600.9(23.66)"
Average rainy days (>= 1mm)             "5.6"         "90.6"
Average afternoon relative humidity (%) "47"          "51"
Mean monthly sunshine hours             "279"         "2,191"
\end{Soutput}
\end{Schunk}

Commas that are used as thousands separators (commas surrounded
by digits) should be dropped:

\begin{Schunk}
\begin{Sinput}
R> x[, ] <- stri_replace_all_regex(x, "(?<=\\d),(?=\\d)", "")
\end{Sinput}
\end{Schunk}

The numbers and alternative units in parentheses are redundant,
therefore these should be taken care of as well:

\begin{Schunk}
\begin{Sinput}
R> x[, ] <- stri_replace_all_regex(x,
+    "(\\d+(?:\\.\\d+)?)\\(\\d+(?:\\.\\d+)?\\)", "$1")
R> dimnames(x)[[1]] <- stri_replace_all_fixed(dimnames(x)[[1]],
+    c(" (°F)", " (inches)"), c("", ""), vectorise_all=FALSE)
\end{Sinput}
\end{Schunk}

At last, \code{as.numeric()} can be used to re-interpret all the strings
as numbers:

\begin{Schunk}
\begin{Sinput}
R> x <- structure(as.numeric(x), dim=dim(x), dimnames=dimnames(x))
R> x[, c(1, 6, ncol(x))]  # example columns
\end{Sinput}
\begin{Soutput}
                                          Jan   Jun   Year
Record high °C                           45.6  22.4   46.4
Average high °C                          27.0  15.1   20.8
Daily mean °C                            21.6  11.7   16.2
Average low °C                           16.1   8.2   11.6
Record low °C                             5.5  -2.2   -2.8
Average rainfall mm                      44.2  49.5  600.9
Average rainy days (>= 1mm)               5.6   8.6   90.6
Average afternoon relative humidity (%)  47.0  61.0   51.0
Mean monthly sunshine hours             279.0 108.0 2191.0
\end{Soutput}
\end{Schunk}

We now have a cleansed matrix at our disposal.
We can, for instance, compute the monthly temperature ranges:

\begin{Schunk}
\begin{Sinput}
R> x["Record high °C", -ncol(x)] - x["Record low °C", -ncol(x)]
\end{Sinput}
\begin{Soutput}
 Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec
40.1 41.9 38.9 33.4 29.8 24.6 26.1 28.6 31.9 36.8 38.4 39.3
\end{Soutput}
\end{Schunk}

\noindent
or the average daily precipitation:

\begin{Schunk}
\begin{Sinput}
R> sum(x["Average rainfall mm", -ncol(x)]) / 365.25
\end{Sinput}
\begin{Soutput}
[1] 1.6463
\end{Soutput}
\end{Schunk}

\noindent
and so forth.

For the climate data on other cities, very similar operations
will need to be performed -- the whole process of scraping and cleansing data
can be automated quite easily.
The above functions are not only convenient to use, but also efficient
and portable across different platforms.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{General design principles}\label{Sec:design}

The API of the early releases of \pkg{stringi} has been designed so as
to be fairly compatible with that of the 0.6.2 version of the
\pkg{stringr} package
\citep{Wickham2010:stringr} (dated 2012; see Table~\ref{Tab:oldstringr}),
with some fixes in the
consistency of the handling of missing values and zero-length vectors,
amongst others.
However, instead of being merely thin wrappers around base \proglang{R}
functions, which we have identified as not necessarily portable across
platforms and not really suitable for natural language processing tasks,
all the functionality has been implemented from the ground up,
with the use of \pkg{ICU} services wherever applicable. Since the
initial release, an abundance of new features has been added
and the package can now be considered a comprehensive workhorse
for text data processing.
Note that the \pkg{stringi} API is stable.
Future releases are aiming for as much backward compatibility
as possible so that other software projects can safely rely on it.


% stringr 0.6.2:
% vectorisation wrt all arguments was there with recycling
% str_c - recycling rule, but NA=="NA" and character(0) fail.
% str_dup - same
% str_count - NA pattern not supported, NA string treated as "NA"
% pattern spec like ignore.case(fixed("SPAM"))

% install.packages(repos=NULL, type="source",
%   "https://cran.r-project.org/src/contrib/Archive/stringr/stringr_0.6.2.tar.gz")
%
% library("stringr")
%
% unlist(packageDescription("stringr")[c("Version", "Date/Publication")])
% ##               Version      Date/Publication
% ##               "0.6.2" "2012-12-06 08:39:59"
%
% str_c(character(0), LETTERS[1:6])
% ## [1] "A" "B" "C" "D" "E" "F"
%
% str_c(c(NA, "a"), LETTERS[1:6])
% ## [1] "NAA" "aB"  "NAC" "aD"  "NAE" "aF"
%
% str_detect(c(NA, "a"), LETTERS[1:6])
% ## [1]    NA FALSE    NA FALSE    NA FALSE
%
% str_detect(character(0), LETTERS[1:6])
% ## Error in mapply(FUN = "grepl", SIMPLIFY = FALSE, USE.NAMES = FALSE, c("A",  :
% ##   zero-length inputs cannot be mixed with those of non-zero length
%
% str_dup(c(NA, "a"), 1:6)
% ## [1] "NA"         "aa"         "NANANA"     "aaaa"       "NANANANANA"
% ## [6] "aaaaaa"
%
% str_dup(character(0), 1:6)
% ## Error in data.frame(string, times) :
% ##   arguments imply differing number of rows: 0, 6
%
% str_locate_all(c("bacon spam spam", "spam", "eggs"), ignore.case(fixed("SPAM")))
% ## [[1]]
% ##      start end
% ##
% ## [[2]]
% ##      start end
% ##
% ## [[3]]
% ##      start end
% ##
% ## Warning message:
% ## In gregexpr("SPAM", c("bacon spam spam", "spam", "eggs"), fixed = TRUE,  :
% ##   argument 'ignore.case = TRUE' will be ignored
%
% str_locate(c("bacon spam spam", "spam", "eggs"), "spam")
% ##      start end
% ## [1,]     7  10
% ## [2,]     1   4
% ## [3,]    NA  NA
%
% str_locate_all(c("bacon spam spam", "spam", "eggs"), "spam")
% ## [[1]]
% ##      start end
% ## [1,]     7  10
% ## [2,]    12  15
% ##
% ## [[2]]
% ##      start end
% ## [1,]     1   4
% ##
% ## [[3]]
% ##      start end
%
% str_extract_all(c("bacon spam spam", "spam eggs", "eggs spam", "spam eggs"), c("spam", "eggs"))
% ## [[1]]
% ## [1] "spam" "spam"
% ##
% ## [[2]]
% ## [1] "eggs"
% ##
% ## [[3]]
% ## [1] "spam"
% ##
% ## [[4]]
% ## [1] "eggs"
%
% str_extract_all(c("bacon spam spam", "spam eggs", "eggs spam", "spam eggs"), c("spam", NA))
% ## Error in (function (pattern, text, ignore.case = FALSE, perl = FALSE,  :
% ##   invalid 'pattern' argument
%
% str_extract_all(c("bacon spam spam", "spam eggs", "eggs spam", NA), c("spam", "eggs"))
% ## [[1]]
% ## [1] "spam" "spam"
% ##
% ## [[2]]
% ## [1] "eggs"
% ##
% ## [[3]]
% ## [1] "spam"
% ##
% ## [[4]]
% ## character(0)
%
% str_count(c("bacon spam spam", "spam eggs", "eggs spam", NA), c("spam", "NA"))
% ## [1] 2 0 1 1
%
% str_count(c("bacon spam spam", "spam eggs", "eggs spam", NA), c("spam", NA))
% ## Error in (function (pattern, text, ignore.case = FALSE, perl = FALSE,  :
% ##   invalid 'pattern' argument





\subsection{Naming}

Function and argument names use a combination of lowercase letters
and underscores (and no dots). To avoid namespace clashes,
all function names feature the ``\code{stri_}'' prefix.
Names are fairly self-explanatory, e.g.,
\code{stri_locate_first_regex} and \code{stri_locate_all_fixed}
find, respectively, the first match to a regular expression and
all occurrences of a substring as-is.

% There are also synonyms for certain operations,
% but actually maybe we should have them deprecated...
% \code{stri_locate_all_fixed(haystack, needle)}
% \code{stri_locate(haystack, fixed=needle, mode="all")}
% \code{stri_locate_all(haystack, fixed=needle)}




\subsection{Vectorisation}

Individual character (or code point) strings can be entered using
double quotes or apostrophes:

\begin{Schunk}
\begin{Sinput}
R> "spam"  # or 'spam'
\end{Sinput}
\begin{Soutput}
[1] "spam"
\end{Soutput}
\end{Schunk}

However, as the  \proglang{R} language does not feature any
classical scalar types, strings are wrapped around atomic vectors
of type ``\code{character}'':

\begin{Schunk}
\begin{Sinput}
R> typeof("spam")  # object type; see also is.character() and is.vector()
\end{Sinput}
\begin{Soutput}
[1] "character"
\end{Soutput}
\begin{Sinput}
R> length("spam")  # how many strings are in this vector?
\end{Sinput}
\begin{Soutput}
[1] 1
\end{Soutput}
\end{Schunk}

\noindent
Hence, we will be using the terms ``string'' and ``character vector
of length 1'' interchangeably.

Not having a separate scalar type is very convenient; the so-called
\emph{vectorisation} strategy encourages writing code that
processes \textit{whole} collections of objects, all at once,
regardless of their size.

For instance, given the following character vector:


\begin{Schunk}
\begin{Sinput}
R> pythons <- c("Graham Chapman", "John Cleese", "Terry Gilliam",
+    "Eric Idle", "Terry Jones", "Michael Palin")
\end{Sinput}
\end{Schunk}

\noindent
we can separate the first and the last names from
each other (assuming for simplicity that no middle names are given),
using just a single function call:

\begin{Schunk}
\begin{Sinput}
R> (pythons <- stri_split_fixed(pythons, " ", simplify=TRUE))
\end{Sinput}
\begin{Soutput}
     [,1]      [,2]
[1,] "Graham"  "Chapman"
[2,] "John"    "Cleese"
[3,] "Terry"   "Gilliam"
[4,] "Eric"    "Idle"
[5,] "Terry"   "Jones"
[6,] "Michael" "Palin"
\end{Soutput}
\end{Schunk}

\noindent
Due to {vectorisation}, we can generally
avoid using the \code{for}- and \code{while}-loops
(``for each string in a vector\dots''),
which makes the code much more readable, maintainable, and faster to execute.

% round(c(1, 3.141593, 2.71828), 2)




\subsection{Acting Elementwise with Recycling}


% in other context, recycling rule also allows use to
% operate on "every other, every 3rd, ...." element
% like in k-fold cross-validation,
% some Taylor series expansions, ...

Binary and higher-arity operations in \proglang{R}
are oftentimes vectorised with respect to all arguments
(or at least to the crucial, non-optional ones).
As a prototype, let us consider the binary arithmetic,
logical, or comparison operators
(and, to some extent, \code{paste()},
\code{strrep()}, and more generally \code{mapply()}),
for example the multiplication:



\begin{Schunk}
\begin{Sinput}
R> c(10, -1) * c(1, 2, 3, 4)  # == c(10, -1, 10, -1) * c(1, 2, 3, 4)
\end{Sinput}
\begin{Soutput}
[1] 10 -2 30 -4
\end{Soutput}
\end{Schunk}

\noindent
Calling ``\code{x * y}'' multiplies the \textit{corresponding} components
of the two vectors elementwisely. As one operand happens to be shorter
than another, the former is recycled as many times as necessary
to match the length of the latter (there would be a warning if partial
recycling occurred). Also, acting on a zero-length
input always yields an empty vector.

%   exceptions: \code{collapse} is a single string in \code{stri_join}
% c(1, 2) + numeric(0)
% paste does not behave this way

All functions in \pkg{stringi} follow this convention
(with some obvious exceptions, such as the \code{collapse}
argument in \code{stri_join()}, \code{locale} in \code{stri_datetime_parse()}, etc.).
In particular, all string search functions are vectorised
with respect to both the  \textit{haystack} and the \textit{needle} arguments
(and, e.g., the \textit{replacement} string, if applicable).

Some users, unaware of this rule, might find this behaviour
unintuitive at the beginning and thus miss out on how powerful it is. Therefore, let us enumerate
the most noteworthy scenarios that are possible thanks to the arguments' recycling,
using the call to \code{stri_count_fixed(haystack, needle)}
(which looks for a needle in a haystack)
as an illustration:

\begin{itemize}
\item many strings -- one pattern:

\begin{Schunk}
\begin{Sinput}
R> stri_count_fixed(c("abcd", "abcabc", "abdc", "dab", NA), "abc")
\end{Sinput}
\begin{Soutput}
[1]  1  2  0  0 NA
\end{Soutput}
\end{Schunk}

(there is 1 occurrence of \code{"abc"} in \code{"abcd"},
2 in \code{"abcabc"}, and so forth)

\item one string -- many patterns:

\begin{Schunk}
\begin{Sinput}
R> stri_count_fixed("abcdeabc", c("def", "bc", "abc", NA))
\end{Sinput}
\begin{Soutput}
[1]  0  2  2 NA
\end{Soutput}
\end{Schunk}

(\code{"def"} does not occur in \code{"abcdeabc"},
\code{"bc"} can be found therein twice, etc.)

\item each string -- its own corresponding pattern:

\begin{Schunk}
\begin{Sinput}
R> stri_count_fixed(c("abca", "def", "ghi"), c("a", "z", "h"))
\end{Sinput}
\begin{Soutput}
[1] 2 0 1
\end{Soutput}
\end{Schunk}

(there are two \code{"a"}s in \code{"abca"},
no \code{"z"} in \code{"def"}, and one \code{"h"} in \code{"ghi"})

\item each row in a matrix -- its own corresponding pattern:

\begin{Schunk}
\begin{Sinput}
R> (haystack <- matrix(  # example input
+    do.call(stri_join,
+      expand.grid(
+        c("a", "b", "c"), c("a", "b", "c"), c("a", "b", "c")
+      )), nrow=3))
\end{Sinput}
\begin{Soutput}
     [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]
[1,] "aaa" "aba" "aca" "aab" "abb" "acb" "aac" "abc" "acc"
[2,] "baa" "bba" "bca" "bab" "bbb" "bcb" "bac" "bbc" "bcc"
[3,] "caa" "cba" "cca" "cab" "cbb" "ccb" "cac" "cbc" "ccc"
\end{Soutput}
\begin{Sinput}
R> needle <- c("a", "b", "c")
R> matrix(stri_count_fixed(haystack, needle),  # call to stringi
+    nrow=3, dimnames=list(needle, NULL))
\end{Sinput}
\begin{Soutput}
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
a    3    2    2    2    1    1    2    1    1
b    1    2    1    2    3    2    1    2    1
c    1    1    2    1    1    2    2    2    3
\end{Soutput}
\end{Schunk}

(this looks for \code{"a"} in the 1st row of
\code{haystack}, \code{"b"} in the 2nd row, and \code{"c"} in the 3rd;
in particular, there are 3 \code{"a"}s in \code{"aaa"}, 2 in \code{"aba"},
and 1 \code{"b"} in \code{"baa"};
this is possible due to the fact that matrices are
represented as ``flat'' vectors of length \code{nrow*ncol},
whose elements are read in a column-major (\proglang{Fortran}) order;
therefore, here,
pattern \code{"a"} is being sought in the 1st, 4th, 7th,
\dots{} string in \code{haystack}, i.e., \code{"aaa"}, \code{"aba"}, \code{"aca"}, \dots;
pattern \code{"b"} in the 2nd, 5th, 8th, \dots{} string;
and \code{"c"} in the 3rd, 6th, 9th, \dots{} one)

\medskip
On a side note, to match different patterns
with respect to each \textit{column}, we can (amongst others)
apply matrix transpose twice (\code{t(stri_count_fixed(t(haystack), needle))}).

% or use the \code{rep()} function to properly replicate the \textit{needles}:

% <<>>=
% (At <- t(haystack))  # example haystack
% needle <- rep(c("a", "b", "c"), each=nrow(At))
% matrix(stri_count_fixed(At, needle), ncol=3)
% @
%
% A similar search in the case of a data frame-type input
% (any list of character vectors of identical lengths)
% can be performed by means of a call to \code{mapply()}:
%
%
%
% <<>>=
% (At.df <- as.data.frame(At))
% mapply(stri_count_fixed, At.df, c("a", "b", "c"))
% @

\item all strings -- all patterns:

% TODO: better not use outer -- do not rep needle

\begin{Schunk}
\begin{Sinput}
R> haystack <- c("aaa", "bbb", "ccc", "abc", "cba", "aab", "bab", "acc")
R> needle <- c("a", "b", "c")
R> structure(
+    outer(haystack, needle, stri_count_fixed),
+    dimnames=list(haystack, needle))  # add row and column names
\end{Sinput}
\begin{Soutput}
    a b c
aaa 3 0 0
bbb 0 3 0
ccc 0 0 3
abc 1 1 1
cba 1 1 1
aab 2 1 0
bab 1 2 0
acc 1 0 2
\end{Soutput}
\end{Schunk}

(which computes the counts over the Cartesian product
of the two arguments)

\ifnotJSSversion
Equivalently:

\begin{Schunk}
\begin{Sinput}
R> matrix(
+    stri_count_fixed(rep(haystack, each=length(needle)), needle),
+    byrow=TRUE, ncol=length(needle), dimnames=list(haystack, needle))
\end{Sinput}
\begin{Soutput}
    a b c
aaa 3 0 0
bbb 0 3 0
ccc 0 0 3
abc 1 1 1
cba 1 1 1
aab 2 1 0
bab 1 2 0
acc 1 0 2
\end{Soutput}
\end{Schunk}
\fi

\end{itemize}


% NOTE:
% In `stri_subset*`
%   and their replacement versions, `pattern` and `value` cannot be longer
%   than `str` (but now they are recycled if necessary).




\subsection{Missing values}

Some base \code{R} string processing functions,
e.g., \code{paste()}, treat missing values as literal \code{"NA"}
strings.
\pkg{stringi}, however, \textit{does} enforce the consistent
propagation of missing values (like arithmetic operations):

\begin{Schunk}
\begin{Sinput}
R> paste(c(NA_character_, "b", "c"), "x", 1:2)  # base R
\end{Sinput}
\begin{Soutput}
[1] "NA x 1" "b x 2"  "c x 1"
\end{Soutput}
\begin{Sinput}
R> stri_join(c(NA_character_, "b", "c"), "x", 1:2)  # stringi
\end{Sinput}
\begin{Soutput}
Warning: longer object length is not a multiple of shorter object length
\end{Soutput}
\begin{Soutput}
[1] NA    "bx2" "cx1"
\end{Soutput}
\end{Schunk}

For dealing with missing values, we may rely on the
convenience functions such as \code{stri_omit_na()} or
\code{stri_replace_na()}.
% and, if additionally we would like to remove empty strings in a vector,
% \code{stri_omit_empty_na()}:
%
% #stri_replace_na(x, "<NA>") %s+% "!"
% stri_omit_empty_na(x) %s+% "!"



\subsection{Data flow}

All vector-like arguments (including factors and objects)
in \pkg{stringi} are treated in the same manner:
for example, if a function expects a character vector on input
and an object of other type is provided,
\code{as.character()} is called first
(we see that in the example above,
``\code{1:2}'' is treated as \code{c("1", "2")}).






% The functions are, of course,  pipe operator-friendly:
%
% % <<>>=
% % y |> stri_sub_replace(24, length=5, replacement="spam") # bacon → spam
% % @
%
%
% <<>>=
% y <- "spam, spam, eggs, bacon, and tasty spam"
% y |> stri_locate_all(., fixed="spam") |> stri_sub_replace_all(y, ., replacement="ham")
% @



% order of inputs - "x" goes first

% When a character vector argument is expected, factors and other vectors
% coercible to characters vectors are silently converted with as.character,
% otherwise an error is generated. Coercion from a list of non-atomic
% vectors each of length 1 issues a warning.
%
% When a logical, numeric, or integer vector argument is expected,
% factors are converted with as.*(as.character(...)), and other
% coercible vectors are converted with as.*, otherwise an error is generated.
%
% Generally, all our functions drop input objects' attributes
% (e.g., names, dim, etc.). This is generally because of advanced
% vectorization and for efficiency reasons. Thus, if arguments'
% preserving is needed, please remember to copy important attributes
% manually or use, e.g., the subsetting operation like x[] <- stri_...(x, ...).


Following \citep{Wickham2010:stringr}, \pkg{stringi}
makes sure the output data types are consistent
and that different functions are interoperable.
This makes operation chaining easier and less error prone.

For example, \code{stri_extract_first_regex()}
finds the first occurrence of a pattern in each string,
therefore the output is a character of the same length
as the input (with recycling rule in place if necessary).



% character vectors or list of character vectors
%
% matrices or lists of matrices
%
% integer vectors or lists of integer vectors
%
% etc.





\begin{Schunk}
\begin{Sinput}
R> haystack <- c("bacon", "spam", "jam, spam, bacon, and spam")
R> stri_extract_first_regex(haystack, "\\b\\w{1,4}\\b")
\end{Sinput}
\begin{Soutput}
[1] NA     "spam" "jam"
\end{Soutput}
\end{Schunk}

Note that a no-match (here, we have been looking for words
of at most 4 characters)
is marked with a missing string.
This makes the output vector size consistent with the length of
the inputs.

On the other hand, \code{stri_extract_all_regex()}
identifies all occurrences of a pattern, whose counts may differ from input to input,
therefore it yields a list of character vectors.

\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex(haystack, "\\b\\w{1,4}\\b", omit_no_match=TRUE)
\end{Sinput}
\begin{Soutput}
[[1]]
character(0)

[[2]]
[1] "spam"

[[3]]
[1] "jam"  "spam" "and"  "spam"
\end{Soutput}
\end{Schunk}

If the 3rd argument was not specified, a no-match
would be represented by a missing value (for consistency with the
previous function).


Also, care is taken so that the ``data'' or ``\code{x}''
argument is most often listed as the first one
(e.g., in base \proglang{R} we have \code{grepl(needle, haystack)}
vs \code{stri\_detect(haystack, needle)} here).
% \code{stri_sprintf()} being one of exceptions to this rule, though).
This makes the functions more intuitive to use,
but also more forward pipe operator-friendly
(either when using ``\code{|>}'' introduced in \proglang{R} 4.1
or ``\code{\%>\%}'' from \pkg{magrittr}).


Furthermore, for increased convenience, some functions have been added
despite the fact that they can be trivially reduced to a series of
other calls.
In particular, writing:

\begin{Schunk}
\begin{Sinput}
R> stri_sub_all(haystack,
+    stri_locate_all_regex(haystack, "\\b\\w{1,4}\\b", omit_no_match=TRUE))
\end{Sinput}
\end{Schunk}

\noindent
yields the same result as in the previous example,
but refers to \code{haystack} twice.


\subsection{Further deviations from base R}

\pkg{stringi} can be used as a replacement of the existing string
processing functions. Also, it offers many
facilities not available in base \proglang{R}.
Except for being fully vectorised with respect to all crucial
arguments, propagating missing values and empty vectors consistently,
and following coherent naming conventions, our functions
deviate from their classic counterparts even further.




% <<>>=
% x <- matrix(LETTERS, nrow=2, dimnames=list(c("alpha", "beta"), NULL))
% x[] <- stri_trans_tolower(x)
% print(x)
% @


\paragraph{Following Unicode standards.}
Thanks to the comprehensive coverage of the most important
services provided by \pkg{ICU}, its users gain access to
collation, pattern searching, normalisation, transliteration, etc.,
that follow the recent Unicode standards for text processing
in any locale.
Due to this, as we state in Section~\ref{Sec:encoding},
all inputs are converted to Unicode and outputs are always
in UTF-8.



\paragraph{Portability issues in base \proglang{R}.}
As we have mentioned in the introduction,
base \proglang{R} string operations have traditionally been
limited in scope. There also might be some issues with regards to their portability,
reasons for which may be plentiful.
For instance, varied versions of the
\pkg{PCRE} (8.x or 10.x)
pattern matching libraries may be linked to
during the compilation of \proglang{R}. On Windows, there is a custom implementation
of \pkg{iconv} that has a set of character encoding
IDs not fully compatible with that on GNU/Linux: to select
the Polish locale, we are required to pass \code{"Polish\_Poland"}
to \code{Sys.setlocale()} on Windows whereas \code{"pl\_PL"} on
Linux.
Interestingly, \proglang{R} can be built against the system \pkg{ICU}
so that it uses its Collator for comparing strings (e.g., using the ``\code{<=}''
operator), however this is only optional and does not provide access to any
other Unicode services.


%
% A call to \code{extSoftVersion()} reports on the versions of
% third-party software  used by \proglang{R}.
% some resources might not be unavailable/not installed
% resources (e.g., locales) may be fetched by means of different IDs
% not necessarily the fastest
% %                      PCRE                       ICU                       TRE                     iconv
% %        "10.34 2019-11-21"                    "66.1" "TRE 0.8.0 R_fixes (BSD)"              "glibc 2.31"
% %
% %        PCRE                       ICU     TRE                        iconv
% % "8.42 2018-03-20"          "55.1"  "TRE 0.8.0 R_fixes (BSD)"  "win_iconv"









% <<>>=
% oldlocale <- Sys.getlocale("LC_COLLATE")
% Sys.setlocale("LC_COLLATE", "sk_SK")
% sort(c("hladný", "chladný"))
% Sys.setlocale("LC_COLLATE", oldlocale)
% @
%
%
% % Warning message:
% % In Sys.setlocale("LC_COLLATE", "sk_SK") :
% %   OS reports request to set locale to "sk_SK" cannot be honored
% %
%
%
% This code works on my Linux, but is not portable. It's because:
%
%     Other Linux users may not have Slovak rule-base installed (and not everyone has abilities to do it on his/her own).
%     Windows users don't use BCP 47-based locale names. There, LCID \code{Slovak_Slovakia.1250} is appropriate.
%
% And so on.





% x <- "AEZaezĄĘŻąęż"
% stri_sub(x, gregexpr("[[:alpha:]]", x, perl=FALSE)[[1]], length=1)
% #stri_sub(x, gregexpr("\\p{L}", x, perl=FALSE)[[1]], length=1)
% stri_sub(x, gregexpr("[[:alpha:]]", x, perl=TRUE)[[1]], length=1)
% stri_sub(x, gregexpr("\\p{L}", x, perl=TRUE)[[1]], length=1)
% stri_extract_all_regex(x, "[[:alpha:]]")[[1]]
% stri_extract_all_regex(x, "\\p{L}")[[1]]
%
%
% Linux (UTF-8 locale):
%  [1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
% [1] "A" "E" "Z" "a" "e" "z"
%  [1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
%  [1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
%  [1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"

% Windows (UTF-8)
%
%  stri_sub(x, gregexpr("[[:alpha:]]", x, perl=FALSE)[[1]], length=1)
% [1] "A" "E" "Z" "a" "e" "z"
% > #stri_sub(x, gregexpr("\\p{L}", x, perl=FALSE)[[1]], length=1)
% > stri_sub(x, gregexpr("[[:alpha:]]", x, perl=TRUE)[[1]], length=1)
% [1] "A" "E" "Z" "a" "e" "z"
% > stri_sub(x, gregexpr("\\p{L}", x, perl=TRUE)[[1]], length=1)
%  [1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
% > stri_extract_all_regex(x, "[[:alpha:]]")[[1]]
%  [1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
% > stri_extract_all_regex(x, "\\p{L}")[[1]]
%  [1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"

%
% > stri_sub(x, gregexpr("[[:alpha:]]", x, perl=FALSE)[[1]], length=1)
% [1] "A" "E" "Z" "a" "e" "z" "Ę" "ę"
% > #stri_sub(x, gregexpr("\\p{L}", x, perl=FALSE)[[1]], length=1)
% > stri_sub(x, gregexpr("[[:alpha:]]", x, perl=TRUE)[[1]], length=1)
%  [1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
% > stri_sub(x, gregexpr("\\p{L}", x, perl=TRUE)[[1]], length=1)
% [1] "A" "E" "Z" "a" "e" "z" "Ę" "ę"
% > stri_extract_all_regex(x, "[[:alpha:]]")[[1]]
%  [1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
% > stri_extract_all_regex(x, "\\p{L}")[[1]]
%  [1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"

% FUTURE: Universal C Runtime UCRT Windows
% https://developer.r-project.org/Blog/public/2020/05/02/utf-8-support-on-windows/index.html




For example, let us consider the matching
of ``all letters'' by means of the built-in \code{gregexpr()} function
and the \pkg{TRE} (\code{perl=FALSE})
and \pkg{PCRE} (\code{perl=TRUE}) libraries
using a POSIX-like and Unicode-style character set
(see Section~\ref{Sec:regex} for more details):

\begin{Schunk}
\begin{Sinput}
R> x <- "AEZaezĄĘŻąęż"  # "AEZaez\u0104\u0118\u017b\u0105\u0119\u017c"
R> stri_sub(x, gregexpr("[[:alpha:]]", x, perl=FALSE)[[1]], length=1)
R> stri_sub(x, gregexpr("[[:alpha:]]", x, perl=TRUE)[[1]],  length=1)
R> stri_sub(x, gregexpr("\\p{L}", x, perl=TRUE)[[1]],       length=1)
\end{Sinput}
\end{Schunk}

On Ubuntu Linux 20.04 (UTF-8 locale), the respective outputs are:

\begin{Schunk}
\begin{Soutput}
[1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
[1] "A" "E" "Z" "a" "e" "z"
[1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
\end{Soutput}
\end{Schunk}

On Windows, when \code{x} is marked as UTF-8
(see Section \ref{Sec:encoding}), the author obtained:

\begin{Schunk}
\begin{Soutput}
[1] "A" "E" "Z" "a" "e" "z"
[1] "A" "E" "Z" "a" "e" "z"
[1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
\end{Soutput}
\end{Schunk}

And again on Windows using the Polish locale
but \code{x} marked as natively-encoded (CP-1250 in this case):

\begin{Schunk}
\begin{Soutput}
[1] "A" "E" "Z" "a" "e" "z" "Ę" "ę"
[1] "A" "E" "Z" "a" "e" "z" "Ą" "Ę" "Ż" "ą" "ę" "ż"
[1] "A" "E" "Z" "a" "e" "z" "Ę" "ę"
\end{Soutput}
\end{Schunk}

As we mention in Section~\ref{Sec:collator},
when \pkg{stringi} links to \pkg{ICU} built from sources
(\code{install.pa\-ckages("stringi", configure.args="--disable-pkg-config")}),
we are always guaranteed to get the same results on every platform.




\paragraph{High performance of \pkg{stringi}.}
Because of the aforementioned reasons, functions in \pkg{stringi}
do not refer to their  base \proglang{R} counterparts.
The operations that do not rely on \pkg{ICU} services
have been rewritten from scratch with speed and portability in mind.
For example, here are some timings of string concatenation:


\begin{Schunk}
\begin{Sinput}
R> x <- stri_rand_strings(length(LETTERS)*1000, 1000)
R> microbenchmark::microbenchmark(
+    join2=stri_join(LETTERS, x, sep="", collapse=", "),
+    join3=stri_join(x, LETTERS, x, sep="", collapse=", "),
+    r_paste2=paste(LETTERS, x, sep="", collapse=", "),
+    r_paste3=paste(x, LETTERS, x, sep="", collapse=", ")
+  )
\end{Sinput}
\begin{Soutput}
Unit: milliseconds
     expr     min      lq    mean  median      uq    max neval
    join2  35.136  37.574  52.371  39.285  54.978 111.37   100
    join3  79.476  84.985  89.886  87.205  92.813 139.65   100
 r_paste2  93.374  98.611 117.285 102.867 116.920 209.74   100
 r_paste3 199.777 211.263 253.166 269.168 281.453 316.77   100
\end{Soutput}
\end{Schunk}

Another example -- timings of fixed pattern searching:

\begin{Schunk}
\begin{Sinput}
R> x <- stri_rand_strings(100, 100000, "[actg]")
R> y <- "acca"
R> microbenchmark::microbenchmark(
+    fixed=stri_locate_all_fixed(x, y),
+    regex=stri_locate_all_regex(x, y),
+    coll=stri_locate_all_coll(x, y),
+    r_tre=gregexpr(y, x),
+    r_pcre=gregexpr(y, x, perl=TRUE),
+    r_fixed=gregexpr(y, x, fixed=TRUE)
+  )
\end{Sinput}
\begin{Soutput}
Unit: milliseconds
    expr      min       lq     mean   median       uq      max neval
   fixed   4.9039   5.1316   5.2745   5.2508   5.3741   6.0388   100
   regex 119.5421 124.3005 127.4752 128.1555 129.2322 147.5276   100
    coll 375.7308 391.6492 396.9924 399.2666 404.0569 424.8703   100
   r_tre 129.0912 133.9986 137.2447 137.6145 139.5300 149.9712   100
  r_pcre  73.5176  76.0573  78.3059  78.4355  79.5072  91.2761   100
 r_fixed  44.2047  45.3858  46.8099  46.9502  47.8690  54.1331   100
\end{Soutput}
\end{Schunk}


\paragraph{Different default argument and greater configurability.}
Some functions in \pkg{stringi} have different,
more natural default arguments,
e.g., \code{paste()} has \code{sep=" "} but
\code{stri_join()} has \code{sep=""}.
Also, as there is no one-fits-all solution to all problems,
many arguments have been introduced for more detailed tuning.

\paragraph{Preserving attributes.}
Generally, \pkg{stringi} preserves no object attributes
whatsoever, but a user can make sure themself
that this is becomes the case, e.g., by calling
``\code{x[] <- stri_...(x, ...)}''
or ``\code{`attributes<-`(stri_...(x, ...), attributes(x))}''.





% \paragraph{A note on the \pkg{stringx} package.}
% The \pkg{stringx} package \citep{stringx} offers Unicode-aware
% drop-in replacements for base \proglang{R} string processing functions.
% It is implemented using \pkg{stringi},
% hence many concepts described herein shall apply to the said package
% as well.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Basic string operations}\label{Sec:basic}

Let us proceed with a detailed description of the most important
facilities in the \pkg{stringi} package that might be of interest to
the broad statistical and data analysis audience.



\subsection{Computing length and width}


First we shall review the functions related to determining
the number of \textit{entities} in each string.



% \paragraph{Length.}
Let us consider the following character vector:

\begin{Schunk}
\begin{Sinput}
R> x <- c("spam", "你好", "\u200b\u200b\u200b", NA_character_, "")
\end{Sinput}
\end{Schunk}

The \code{x} object consists of 5 character strings:

\begin{Schunk}
\begin{Sinput}
R> length(x)
\end{Sinput}
\begin{Soutput}
[1] 5
\end{Soutput}
\end{Schunk}


\code{stri_length()} computes the \textit{length} of each string.
More precisely, the function gives the number of Unicode code points
in each string, see Section~\ref{Sec:codepoints} for more details.

\begin{Schunk}
\begin{Sinput}
R> stri_length(x)
\end{Sinput}
\begin{Soutput}
[1]  4  2  3 NA  0
\end{Soutput}
\end{Schunk}

\noindent
% \code{stri_length(x)} returns a numeric vector \code{s},
% with the same number of elements as \code{x}, such that, for every \code{i},
% \code{s[i]} is the length of the string \code{x[i]}.
The first string carries 4 ASCII (English) letters,
the second consists of 2 Chinese characters (U+4F60, U+597D; a greeting),
and the third one is comprised of 3 zero-width spaces (U+200B).
Note that the 5th element in \code{x} is an empty string, \code{""},
hence its length is  0.
Moreover, there is a missing (\code{NA}) value
at index 4, therefore the corresponding length is \textit{undefined} as well.
% \pkg{stringi} applies this rule consistently across all its functions.




% \paragraph{Width.}
When formatting strings for display
(e.g., in a report dynamically generated with \code{Sweave()}
or \pkg{knitr}; see \citealp{knitr}),
a string's \textit{width} estimate may be more informative --
an approximate number of text columns it will occupy when printed
using a monospaced font.
In particular, many Chinese, Japanese, Korean, and most emoji
characters take up two text cells. Some code points, on the other hand,
might be of width 0 (e.g., the above ZERO WIDTH SPACE, U+200B).



% \begin{CJK*}{UTF8}{bsmi}
\begin{Schunk}
\begin{Sinput}
R> stri_width(x)
\end{Sinput}
\begin{Soutput}
[1]  4  4  0 NA  0
\end{Soutput}
\end{Schunk}
% \end{CJK*}

\noindent



% SKIP: stri_numbytes

% SKIP: stri_isempty

%\paragraph{Zero-length.}
%To quickly determine which of the items are empty strings, we may call:
%
%<<>>=
%stri_isempty(x)
%@
%
%\noindent
%Note that we distinguish between an empty character vector
%(\code{character(0)}, i.e., a zero-length sequence)
%and an empty string, i.e., a string of length 0 wrapped in a vector
%of length~1.
%
%<<>>=
%length(character(0))      # no strings at all
%stri_length(character(0))
%length("")                # one empty string
%stri_length("")
%@









\subsection{Joining}

Below we describe the functions that are related to string concatenation.


\paragraph{Operator \code{\%s+\%}.}
To join  the corresponding strings in two character vectors,
we may use the binary \code{\%s+\%} operator:

\begin{Schunk}
\begin{Sinput}
R> x <- c("tasty", "delicious", "yummy", NA)
R> x %s+% " " %s+% c("spam", "bacon")
\end{Sinput}
\begin{Soutput}
[1] "tasty spam"      "delicious bacon" "yummy spam"      NA
\end{Soutput}
\end{Schunk}

% character(0) %s+% c("spam", "bacon")

% This operator is vectorised in exactly the same manner
% as other arithmetic operators in \proglang{R}.
% In particular, the recycling rule is used if the inputs are of different
% lengths. If one of the arguments is empty, the result is a zero-length
% vector as well. Moreover, \pkg{stringi} \textit{does} enforce the consistent
% propagation of missing values
% (unlike the built-in \code{paste()} function):
%
% <<>>=
% x <- c("spam", "bacon", "", "sausage", NA, "spam")
% x %s+% "!"
% @




\paragraph{Flattening.}
The elements in a character vector can be joined (``aggregated'')
to form a single string via a call to  \code{stri\_flatten()}:

\begin{Schunk}
\begin{Sinput}
R> stri_flatten(stri_omit_na(x), collapse=", ")
\end{Sinput}
\begin{Soutput}
[1] "tasty, delicious, yummy"
\end{Soutput}
\end{Schunk}

\noindent
Note that the token separator, given by the \code{collapse} argument,
defaults to the empty string.



\paragraph{Generalisation.}
Both the \code{\%s+\%} operator and the \code{stri\_flatten()} function
are generalised by
\code{stri\_join()} (alias: \code{stri\_paste()}, \code{stri\_c()}):

\begin{Schunk}
\begin{Sinput}
R> stri_join(c("X", "Y", "Z"), 1:6, "a")  # sep="", collapse=NULL
\end{Sinput}
\begin{Soutput}
[1] "X1a" "Y2a" "Z3a" "X4a" "Y5a" "Z6a"
\end{Soutput}
\end{Schunk}

By default, the \code{sep} argument, which controls how corresponding
strings are delimited, is set to the empty string
(like in the base \code{paste0()} but unlike in \code{paste()}).
Moreover, \code{collapse} is \code{NULL}, which means that
the resulting outputs will not be joined to form a single string.
This can be changed if need be:

\begin{Schunk}
\begin{Sinput}
R> stri_join(c("X", "Y", "Z"), 1:6, "a", sep="_", collapse=", ")
\end{Sinput}
\begin{Soutput}
[1] "X_1_a, Y_2_a, Z_3_a, X_4_a, Y_5_a, Z_6_a"
\end{Soutput}
\end{Schunk}



\noindent
Note how the two (1st, 3rd) shorter vectors were {recycled} to match
the longest (2nd) vector's length. The latter was of numeric type,
but it was implicitly coerced via a call to \code{as.character()}.


% paste()  sep="" by default
% paste0() sep=" "
% NA handling, character(0), UTF-8 output as usual in stringi


\ifnotJSSversion
More examples:

\begin{Schunk}
\begin{Sinput}
R> stri_join(pythons[, 2], pythons[, 1], sep=", ")
\end{Sinput}
\begin{Soutput}
[1] "Chapman, Graham" "Cleese, John"    "Gilliam, Terry"  "Idle, Eric"
[5] "Jones, Terry"    "Palin, Michael"
\end{Soutput}
\begin{Sinput}
R> outer(LETTERS[1:3], 1:5, stri_join, sep=".")  # outer product
\end{Sinput}
\begin{Soutput}
     [,1]  [,2]  [,3]  [,4]  [,5]
[1,] "A.1" "A.2" "A.3" "A.4" "A.5"
[2,] "B.1" "B.2" "B.3" "B.4" "B.5"
[3,] "C.1" "C.2" "C.3" "C.4" "C.5"
\end{Soutput}
\end{Schunk}
\fi



\paragraph{Duplicating.}
To duplicate given strings, we call
\code{stri\_dup()} or the \code{\%s*\%} operator:


\begin{Schunk}
\begin{Sinput}
R> stri_dup(letters[1:5], 1:5)  # synonym: letters[1:5] %s*% 1:5
\end{Sinput}
\begin{Soutput}
[1] "a"     "bb"    "ccc"   "dddd"  "eeeee"
\end{Soutput}
\end{Schunk}




\paragraph{Within-list joining.}
There is also a convenience function that applies \code{stri\_flatten()}
on each character vector in a given list:

\begin{Schunk}
\begin{Sinput}
R> words <- list(c("spam", "bacon", "sausage", "spam"), c("eggs", "spam"))
R> stri_join_list(words, sep=", ")  # collapse=NULL
\end{Sinput}
\begin{Soutput}
[1] "spam, bacon, sausage, spam" "eggs, spam"
\end{Soutput}
\end{Schunk}

\ifnotJSSversion
\begin{Schunk}
\begin{Sinput}
R> stri_join_list(words, sep=", ", collapse=";\n")
\end{Sinput}
\begin{Soutput}
[1] "spam, bacon, sausage, spam;\neggs, spam"
\end{Soutput}
\end{Schunk}
\fi

\noindent
This way, a list of character vectors can be converted to
a character vector. Such sequences of variable length sequences of
strings are generated by, amongst others,
\code{stri_sub_all()} and \code{stri_extract_all()}.






\subsection{Extracting and replacing substrings}

Next group of functions deals with the extraction and replacement
of particular sequences of code points in given strings.

\paragraph{Indexing vectors.}
Recall that in order to select a subsequence from any \proglang{R} vector,
we use the square-bracket operator\footnote{More precisely, \code{x[i]}
is a syntactic sugar for a call to \code{`[`(x, i)}.
Moreover, if \code{x} is a list, \code{x[[i]]} can be used to
extract its \code{i}-th element (alias \code{`[[`(x, i)}).
Knowing the ``functional'' form of the operators allows us to, for instance,
extract all first elements from each vector in a list
by simply calling \code{sapply(x, "[[", 1)}.}
with an index vector consisting of either
non-negative integers, negative integers,
or logical values\footnote{If an object's \code{names} attribute is set,
indexing with a character vector is also possible.}.

For example, here is how to select specific elements in a vector:

\begin{Schunk}
\begin{Sinput}
R> x <- c("spam", "buckwheat", "", NA, "bacon")
R> x[1:3]                           # from 1st to 3rd string
\end{Sinput}
\begin{Soutput}
[1] "spam"      "buckwheat" ""
\end{Soutput}
\begin{Sinput}
R> x[c(1, length(x))]               # 1st and last
\end{Sinput}
\begin{Soutput}
[1] "spam"  "bacon"
\end{Soutput}
\end{Schunk}

\noindent
Exclusion of elements at specific positions can be performed like:

\begin{Schunk}
\begin{Sinput}
R> x[-1]                            # all but 1st
\end{Sinput}
\begin{Soutput}
[1] "buckwheat" ""          NA          "bacon"
\end{Soutput}
\end{Schunk}

\noindent
Filtering based on a logical vector can be used to extract
strings fulfilling desired criteria:

\begin{Schunk}
\begin{Sinput}
R> x[!stri_isempty(x) & !is.na(x)]
\end{Sinput}
\begin{Soutput}
[1] "spam"      "buckwheat" "bacon"
\end{Soutput}
\end{Schunk}


\paragraph{Extracting substrings.}
A character vector is, in its very own essence, a sequence of
sequences of code points.
To extract specific substrings from each string in a collection,
we can use the \code{stri\_sub()} function.

\begin{Schunk}
\begin{Sinput}
R> y <- "spam, egg, spam, spam, bacon, and spam"
R> stri_sub(y, 18)             # from 18th code point to end
\end{Sinput}
\begin{Soutput}
[1] "spam, bacon, and spam"
\end{Soutput}
\begin{Sinput}
R> stri_sub(y, 12, to=15)      # from 12th to 15th code point (inclusive)
\end{Sinput}
\begin{Soutput}
[1] "spam"
\end{Soutput}
\end{Schunk}

Negative indices count from the end of a string.

\begin{Schunk}
\begin{Sinput}
R> stri_sub(y, -15, length=5)  # 5 code points from 15th last
\end{Sinput}
\begin{Soutput}
[1] "bacon"
\end{Soutput}
\end{Schunk}




\paragraph{\code{stri\_sub\_all()} function.}
% \ifnotJSSversion
% The \code{stri_sub()}  function is of course vectorised with respect
% to all its arguments
% (the subsetted character vector, \code{from}, and \code{to} or \code{length}).
% If one of the vectors is of smaller length than the other ones,
% the recycling rule is applied as usual. For instance:
%
% <<>>=
% stri_sub(y, c(1, 12, 18), length=4) # different substrings of one string
% stri_sub(x[c(1, 2, 4)], from=-3)    # same substrings of different strings
% stri_sub(x[c(1, 2, 4)],
%   c(-4, -2, -5))  # different substrings of different strings
% @
% \fi
If some deeper vectorisation level is necessary, \code{stri_sub_all()}
comes in handy. It extracts multiple (possibly different) substrings
from all the strings provided:


\begin{Schunk}
\begin{Sinput}
R> (z <- stri_sub_all(
+                c("spam",     "bacon", "sorghum"),
+    from   = list(c(1, 3, 4), -3,      c(2, 4)),
+    length = list(1,           3,      c(4, 3))))
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "s" "a" "m"

[[2]]
[1] "con"

[[3]]
[1] "orgh" "ghu"
\end{Soutput}
\end{Schunk}

As the number of substrings to extract from each string might vary,
the result is a list of character strings.
We have obtained:
substrings of length 1 starting at positions 1, 3, and 4 in \code{x[1]},
then a length-3 substring that starts at the 3rd code point
from the end of \code{x[2]},
and length-4 and -3 substrings starting at, respectively,
the 2nd and 4th code point
of \code{x[3]} (where \code{x} denotes the subsetted vector).


\ifnotJSSversion
Recall that the strings may all be concatenated by means of the
aforementioned \code{stri_join_list()} function.

\begin{Schunk}
\begin{Sinput}
R> stri_join_list(z, sep=", ")
\end{Sinput}
\begin{Soutput}
[1] "s, a, m"   "con"       "orgh, ghu"
\end{Soutput}
\end{Schunk}



There is also a more flexible version
of the built-in \code{simplify2array()} function whose
aim is to convert such lists to matrices.

\begin{Schunk}
\begin{Sinput}
R> stri_list2matrix(z, by_row=TRUE, fill="", n_min=5)
\end{Sinput}
\begin{Soutput}
     [,1]   [,2]  [,3] [,4] [,5]
[1,] "s"    "a"   "m"  ""   ""
[2,] "con"  ""    ""   ""   ""
[3,] "orgh" "ghu" ""   ""   ""
\end{Soutput}
\end{Schunk}
\fi


% Here is a way to extract
% non-consecutive substrings from each string --
% ones that consist of the first and the last letter:
%
% <<>>=
% stri_join_list(stri_sub_all(x[c(1, 2, 4)], c(1, -1), length=1))
% @






\paragraph{``From--to'' and ``from--length'' matrices.}
The second parameter of both \code{stri_sub()} and \code{stri_sub_list()}
can also be fed with a two-column matrix
of the form \code{cbind(from, to)}. Here, the first column
gives the start indices and the second column defines the end ones.
Such matrices are generated, amongst others, by the \code{stri_locate_*()}
functions (see below for details).

\ifnotJSSversion
\begin{Schunk}
\begin{Sinput}
R> (from_to <- cbind(from=c(1, 12, 18), to=c(4, 15, 21))) # +optional labels
\end{Sinput}
\begin{Soutput}
     from to
[1,]    1  4
[2,]   12 15
[3,]   18 21
\end{Soutput}
\begin{Sinput}
R> stri_sub(y, from_to)
\end{Sinput}
\begin{Soutput}
[1] "spam" "spam" "spam"
\end{Soutput}
\end{Schunk}


\noindent Another example (the recycling rule):
\fi

\begin{Schunk}
\begin{Sinput}
R> (from_to <- matrix(1:8, ncol=2, byrow=TRUE))
\end{Sinput}
\begin{Soutput}
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
\end{Soutput}
\begin{Sinput}
R> stri_sub(c("abcdefgh", "ijklmnop"), from_to)
\end{Sinput}
\begin{Soutput}
[1] "ab" "kl" "ef" "op"
\end{Soutput}
\end{Schunk}

\noindent
Due to recycling, this has extracted
elements at positions 1:2 from the 1st string,
at 3:4 from the 2nd one, 5:6 from the 1st, and 7:8 from the 2nd again.

Note the difference between the above output and the following one:

\begin{Schunk}
\begin{Sinput}
R> stri_sub_all(c("abcdefgh", "ijklmnop"), from_to)
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "ab" "cd" "ef" "gh"

[[2]]
[1] "ij" "kl" "mn" "op"
\end{Soutput}
\end{Schunk}

This time, we extract four identical sections from each of the two inputs.


\medskip
Moreover, if the second column of the index matrix is named
\code{"length"} (and only if this is exactly the case),
i.e., the indexer is of the form \code{cbind(from, length=length)},
extraction will be based on the extracted chunk size.




\ifnotJSSversion
\paragraph{Permuting code points.}
Somewhat related to the above are different ways to construct
various permutations (possibly with replacement) of code points in a string:

\begin{Schunk}
\begin{Sinput}
R> stri_join_list(stri_sub_all("spam", c(4, 3, 2, 3, 1), length=1))
\end{Sinput}
\begin{Soutput}
[1] "mapas"
\end{Soutput}
\begin{Sinput}
R> stri_rand_shuffle("bacon")  # random order
\end{Sinput}
\begin{Soutput}
[1] "anobc"
\end{Soutput}
\begin{Sinput}
R> stri_reverse("spam")        # reverse order
\end{Sinput}
\begin{Soutput}
[1] "maps"
\end{Soutput}
\end{Schunk}
\fi

\paragraph{Replacing substrings.}
\code{stri\_sub\_replace()} returns a version
of a character vector with some chunks replaced by other
strings:

\begin{Schunk}
\begin{Sinput}
R> stri_sub_replace(c("abcde", "ABCDE"),
+    from=c(2, 4), length=c(1, 2), replacement=c("X", "uvw"))
\end{Sinput}
\begin{Soutput}
[1] "aXcde"  "ABCuvw"
\end{Soutput}
\end{Schunk}

\noindent
The above replaced ``\code{b}'' (the length-1 substring
starting at index 2 of the 1st string) with ``\code{X}''
and ``\code{DE}''
(the length-2 substring at index 4 of the 2nd string)
with ``\code{uvw}''.


Similarly, \code{stri\_sub\_replace\_all()} replaces
multiple substrings within each string in a character vector:

\begin{Schunk}
\begin{Sinput}
R> stri_sub_replace_all(
+                     c("abcde",  "ABCDE"),
+    from        = list(c(2, 4),  c(0,    3,   6)),
+    length      = list(  1,      c(0,    2,   0)),
+    replacement = list(  "Z",    c("uu", "v", "wwww")))
\end{Sinput}
\begin{Soutput}
[1] "aZcZe"      "uuABvEwwww"
\end{Soutput}
\end{Schunk}

\noindent
Note how we have obtained the insertion of new content
at the start and the end of the 2nd input.


\paragraph{Replacing substrings in-place.}
The corresponding {replacement functions} modify
a character vector in-place:

\begin{Schunk}
\begin{Sinput}
R> y <- "spam, egg, spam, spam, bacon, and spam"
R> stri_sub(y, 7, length=3) <- "spam"  # in-place replacement, egg → spam
R> print(y)                            # y has changed
\end{Sinput}
\begin{Soutput}
[1] "spam, spam, spam, spam, bacon, and spam"
\end{Soutput}
\end{Schunk}

Note that the state of \code{y} has changed in such a way that the
substring of length 3 starting at the 7th code point
was replaced by a length-4 content.

Many replacements within a single string are also possible:

\begin{Schunk}
\begin{Sinput}
R> y <- "aa bb cc"
R> stri_sub_all(y, c(1, 4, 7), length=2) <- c("A", "BB", "CCC")
R> print(y)                            # y has changed
\end{Sinput}
\begin{Soutput}
[1] "A BB CCC"
\end{Soutput}
\end{Schunk}

\noindent
This has replaced 3 length-2 chunks within \code{y} with new content.


% \clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Code-pointwise comparing}\label{Sec:fixed}

There are many circumstances where we are faced with testing
whether two strings (or parts thereof)
consist  of exactly the same Unicode code points, in exactly the same order.
These include, for instance, matching a nucleotide sequence
in a DNA profile and querying for system resources based on file names or UUIDs.
Such tasks, due to their simplicity, can be performed very efficiently.


\subsection{Testing for equality of strings}


% equivalence relation on the set of characters

To quickly test whether the corresponding strings in two character vectors
are identical (in a code-pointwise manner), we can use the \code{\%s===\%}
operator or, equivalently, the \code{stri\_cmp\_eq()} function.
Moreover, \code{\%s!==\%} and \code{stri\_cmp\_neq()}
implement the not-equal-to relation.

\begin{Schunk}
\begin{Sinput}
R> "actg" %s===% c("ACTG", "actg", "act", "actga", NA)
\end{Sinput}
\begin{Soutput}
[1] FALSE  TRUE FALSE FALSE    NA
\end{Soutput}
\end{Schunk}

Due to recycling, the first string was compared against the
5 strings in the 2nd operand. There is only 1 exact match.



\begin{table}[b!]
\centering
\begin{tabularx}{1.0\linewidth}{p{4.8cm}X}
\toprule
\bfseries Name(s) & \bfseries Meaning \\
\midrule
\code{stri\_count()} &  count pattern matches    \\
\midrule
\code{stri\_detect()} & detect pattern matches     \\
\midrule
\code{stri\_endswith()} &  [all but \code{regex}] detect pattern matches at end of string  \\
\midrule
\code{stri\_extract\_all()}, \code{stri\_extract\_first()}, \code{stri\_extract\_last()}  & extract pattern matches     \\
\midrule
\code{stri\_locate\_all()}, \code{stri\_locate\_first()}, \code{stri\_locate\_last()}  & locate pattern matches     \\
\midrule
\code{stri\_match\_all()}, \code{stri\_match\_first()}, \code{stri\_match\_last()}   &  [\code{regex} only] extract matches to regex capture groups   \\
\midrule
\code{stri\_replace\_all()}, \code{stri\_replace\_first()}, \code{stri\_replace\_last()}  &     substitute pattern matches with some replacement strings \\
\midrule
\code{stri\_split()}  & split up a string at pattern matches     \\
\midrule
\code{stri\_startswith()}  &  [all but \code{regex}] detect pattern matches at start of string   \\
\midrule
\code{stri\_subset()}, \code{`stri\_subset<-`()}  & return or replace strings
that contain pattern matches \\
\bottomrule
\end{tabularx}

\caption{\label{Tab:searchfuns} String search/pattern matching functions in \pkg{stringi}.
Each function, unless otherwise indicated, can be used in conjunction
with any search engine, e.g., we have
\code{stri\_count\_fixed()} (see Section~\ref{Sec:fixed}),
\code{stri\_detect\_regex()} (see Section~\ref{Sec:regex}), and
\code{stri\_split\_coll()} (see Section~\ref{Sec:collator}).}
\end{table}


\subsection{Searching for fixed strings}


For detecting if a string contains
a given fixed substring  (code-pointwisely),
the fast KMP \citep{KnuthETAL1977:kmp} algorithm, with worst time complexity of $O(n+p)$
(where $n$ is the length of the string and $p$ is the length of the pattern),
has been implemented in \pkg{stringi} (with numerous tweaks
for even faster matching).

Table~\ref{Tab:searchfuns} lists the string search functions available
in \pkg{stringi}.  Below we explain their behaviour in the context of fixed
 pattern matching. Notably, their description
is quite detailed, because -- as we shall soon find out --
the corresponding operations are available for the two other search
engines: based on regular expressions and the \pkg{ICU} Collator,
see Section~\ref{Sec:regex} and Section~\ref{Sec:collator}.
% It is also worth emphasising that, initially, the most basic string search API
% has been designed so as to be compatible with the early versions
% of the \pkg{stringr} package (compare Table~\ref{Tab:oldstringr}).
% In the course of \pkg{stringi}'s development, many new operations and extensions
% have been introduced.






\subsection{Counting matches}

The \code{stri_count_fixed()} function counts the number of
times a fixed pattern occurs in a given string.

\begin{Schunk}
\begin{Sinput}
R> stri_count_fixed("abcabcdefabcabcabdc", "abc")  # search pattern is "abc"
\end{Sinput}
\begin{Soutput}
[1] 4
\end{Soutput}
\end{Schunk}

\ifnotJSSversion
Equivalently, we can call the more generic (see below)
function \code{stri_count()} with  the \code{fixed=}\textit{pattern} argument:

\begin{Schunk}
\begin{Sinput}
R> stri_count("abcabcdefabcabcabdc", fixed="abc")
\end{Sinput}
\begin{Soutput}
[1] 4
\end{Soutput}
\end{Schunk}
\fi


\ifnotJSSversion
Note that, unlike in the base \proglang{R} \code{grep()} function
(and the like), the pattern (``needle'') is given by the second argument
(here: ``\code{abc}''). This makes our function more
pipe-operator-friendly, because ``haystack'' can be forwarded as follows:

\begin{Schunk}
\begin{Sinput}
R> c("abcabcdefabcabcabdc", "cba", NA) |> stri_count_fixed("abc")
\end{Sinput}
\begin{Soutput}
[1]  4  0 NA
\end{Soutput}
\end{Schunk}
\fi



\subsection{Search engine options}

The pattern matching engine may be tuned up by passing
further arguments to the search functions (via ``\code{...}'';
they are redirected as-is to \code{stri_opts_fixed()}).
Table~\ref{Tab:fixed_opts} gives the list of available options.





First, we may switch on the simplistic\footnote{Which is not suitable
for real-world NLP tasks, as it assumes
that changing the case of a single code point always produces one and only
one item;
This way, \code{"groß"} does not compare equal to \code{"GROSS"},
see Section~\ref{Sec:collator} (and partially Section~\ref{Sec:regex}) for a workaround.}
case-insensitive matching.


\begin{Schunk}
\begin{Sinput}
R> stri_count_fixed("ACTGACGacgggACg", "acg", case_insensitive=TRUE)
\end{Sinput}
\begin{Soutput}
[1] 3
\end{Soutput}
\end{Schunk}

Second, we can indicate our interest in detecting
overlapping pattern matches or whether searching should continue
at the end of each match
(the latter being the default behaviour):

\begin{Schunk}
\begin{Sinput}
R> stri_count_fixed("acatgacaca", "aca")  # overlap=FALSE (default)
\end{Sinput}
\begin{Soutput}
[1] 2
\end{Soutput}
\begin{Sinput}
R> stri_count_fixed("acatgacaca", "aca", overlap=TRUE)
\end{Sinput}
\begin{Soutput}
[1] 3
\end{Soutput}
\end{Schunk}



\begin{table}[t!]
\centering

\begin{tabularx}{1.0\linewidth}{p{4cm}X}
\toprule
\bfseries{Option}            &\bfseries Purpose \\
\midrule
\code{case\_insensitive} & logical; whether to enable the simple
case-insensitive matching (defaults to \code{FALSE}) \\
\midrule
\code{overlap} & logical; whether to enable the detection of overlapping
matches (defaults to \code{FALSE});
available in \code{stri\_extract\_all\_fixed()},
\code{stri\_locate\_all\_fixed()}, and \code{stri\_count\_fixed()}
\\
\bottomrule
\end{tabularx}

\caption{\label{Tab:fixed_opts} Options for the fixed pattern search
engine, see \code{stri\_opts\_fixed()}.}
\end{table}



\subsection{Detecting and subsetting patterns}

A somewhat simplified version of the above search task involves asking
whether a pattern occurs in a string at all. Such an operation can be
performed with a call to \code{stri\_detect\_fixed()}.

\begin{Schunk}
\begin{Sinput}
R> x <- c("abc", "abcd", "def", "xyzabc", "uabdc", "dab", NA, "abc")
R> stri_detect_fixed(x, "abc")
\end{Sinput}
\begin{Soutput}
[1]  TRUE  TRUE FALSE  TRUE FALSE FALSE    NA  TRUE
\end{Soutput}
\end{Schunk}

We can also indicate that a no-match is rather of our  interest
by passing \code{negate=TRUE}.
What is more, there is an option to stop searching
once a given number of matches has been found
in the \code{haystack} vector (as a whole),
which can speed up the processing of larger data sets:

\begin{Schunk}
\begin{Sinput}
R> stri_detect_fixed(x, "abc", negate=TRUE, max_count=2)
\end{Sinput}
\begin{Soutput}
[1] FALSE FALSE  TRUE FALSE  TRUE    NA    NA    NA
\end{Soutput}
\end{Schunk}

\noindent
This can be useful in scenarios such as ``find the first 2 matching
resource IDs''.


\medskip
There are also functions that verify whether a string
starts or ends\footnote{Note that testing for a pattern match at the start
or end of a string has not been implemented separately for \code{regex} patterns,
which support \code{"\textasciicircum"} and \code{"\$"} anchors that  serve exactly this very purpose.}
with a pattern match:

\begin{Schunk}
\begin{Sinput}
R> stri_startswith_fixed(x, "abc")  # from=1 - match at start
\end{Sinput}
\begin{Soutput}
[1]  TRUE  TRUE FALSE FALSE FALSE FALSE    NA  TRUE
\end{Soutput}
\begin{Sinput}
R> stri_endswith_fixed(x, "abc")    # to=-1 - match at end
\end{Sinput}
\begin{Soutput}
[1]  TRUE FALSE FALSE  TRUE FALSE FALSE    NA  TRUE
\end{Soutput}
\end{Schunk}


\medskip
Pattern detection is often performed in conjunction
with character vector subsetting.
This is why we have a specialised (and hence slightly faster)
function that  returns only the strings that match a given pattern.


\begin{Schunk}
\begin{Sinput}
R> stri_subset_fixed(x, "abc", omit_na=TRUE)
\end{Sinput}
\begin{Soutput}
[1] "abc"    "abcd"   "xyzabc" "abc"
\end{Soutput}
\end{Schunk}

The above is equivalent to \code{x[which(stri_detect_fixed(x, "abc"))]}
(note the argument responsible for the removal of missing values),
but avoids writing \code{x} twice.
% The users of the pipe operator might find it particularly convenient:
It hence is particularly convenient when \code{x} is generated
programmatically on the fly, using some complicated expression.
Also, it works well with the forward pipe operator, as we can write
``\code{x |> stri_subset_fixed("abc", omit_na=TRUE)}''.


% stri_subset_fixed(x, "abc", negate=TRUE)  # everything but the matches


There is also a replacement version of this function:

\begin{Schunk}
\begin{Sinput}
R> stri_subset_fixed(x, "abc") <- c("*****", "***")  # modifies x in-place
R> print(x)  # x has changed
\end{Sinput}
\begin{Soutput}
[1] "*****" "***"   "def"   "*****" "uabdc" "dab"   NA      "***"
\end{Soutput}
\end{Schunk}


% In `stri_subset*`
%   and their replacement versions, `pattern` and `value` cannot be longer
%   than `str` (but now they are recycled if necessary).




\subsection{Locating and extracting patterns}

The functions from the \code{stri_locate()} family
aim to pinpoint the positions of pattern matches.
First, we may be interested in getting to know the location of the
first or the last pattern occurrence:

\begin{Schunk}
\begin{Sinput}
R> x <- c("aga", "actg", NA, "AGagaGAgaga")
R> stri_locate_first_fixed(x, "aga")
\end{Sinput}
\begin{Soutput}
     start end
[1,]     1   3
[2,]    NA  NA
[3,]    NA  NA
[4,]     3   5
\end{Soutput}
\begin{Sinput}
R> stri_locate_last_fixed(x, "aga", get_length=TRUE)
\end{Sinput}
\begin{Soutput}
     start length
[1,]     1      3
[2,]    -1     -1
[3,]    NA     NA
[4,]     9      3
\end{Soutput}
\end{Schunk}

\noindent
In both examples we obtain a two-column matrix
with the number of rows determined by the recycling rule (here:
the length of \code{x}).
In the former case, we get a ``from--to'' matrix (\code{get_length=FALSE};
the default) where missing values correspond to either missing inputs or
no-matches. The latter gives a ``from--length''-type matrix,
where negative lengths correspond to the not-founds.

Second, we may be yearning for the locations of all the matching
substrings. As the number of possible answers may vary from string to string,
the result is a list of index matrices.

\begin{Schunk}
\begin{Sinput}
R> stri_locate_all_fixed(x, "aga", overlap=TRUE, case_insensitive=TRUE)
\end{Sinput}
\begin{Soutput}
[[1]]
     start end
[1,]     1   3

[[2]]
     start end
[1,]    NA  NA

[[3]]
     start end
[1,]    NA  NA

[[4]]
     start end
[1,]     1   3
[2,]     3   5
[3,]     5   7
[4,]     7   9
[5,]     9  11
\end{Soutput}
\end{Schunk}

\noindent
Note again that a no-match is indicated by a single-row matrix
with two missing values (or with negative length if \code{get_length=TRUE}).
% stringr v0.6.2 returned empty matrices
This behaviour can be changed by setting the \code{omit_no_match}
argument to \code{TRUE}.


\medskip
Let us recall that ``from--to'' and ``from--length''
matrices of the above kind constitute particularly
fine inputs to \code{stri\_sub()} and \code{stri\_sub\_all()}.
However, if merely the extraction of the matching substrings is needed,
it will be more convenient to rely on the functions from the
\code{stri\_extract()} family:

\begin{Schunk}
\begin{Sinput}
R> stri_extract_first_fixed(x, "aga", case_insensitive=TRUE)
\end{Sinput}
\begin{Soutput}
[1] "aga" NA    NA    "AGa"
\end{Soutput}
\begin{Sinput}
R> stri_extract_all_fixed(x, "aga",
+    overlap=TRUE, case_insensitive=TRUE, omit_no_match=TRUE)
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "aga"

[[2]]
character(0)

[[3]]
[1] NA

[[4]]
[1] "AGa" "aga" "aGA" "Aga" "aga"
\end{Soutput}
\end{Schunk}

% <<>>=
% (res <- stri_extract_first_fixed(x, "aga", case_insensitive=TRUE))
% identical(res, stri_sub(x,
%   stri_locate_first_fixed(x, "aga", case_insensitive=TRUE)))
% (res <- stri_extract_all_fixed(x, "aga",
%   overlap=TRUE, case_insensitive=TRUE, omit_no_match=TRUE))
% identical(res, stri_sub_all(x,
%   stri_locate_all_fixed(x, "aga",
%     omit_no_match=TRUE, overlap=TRUE, case_insensitive=TRUE)))
% @





\subsection{Replacing pattern occurrences}

In order to replace each match with a corresponding
replacement string, we can refer to \code{stri\_replace\_all()}:

\begin{Schunk}
\begin{Sinput}
R> x <- c("aga", "actg", NA, "ggAGAGAgaGAca", "agagagaga")
R> stri_replace_all_fixed(x, "aga", "~", case_insensitive=TRUE)
\end{Sinput}
\begin{Soutput}
[1] "~"         "actg"      NA          "gg~G~GAca" "~g~ga"
\end{Soutput}
\end{Schunk}

Note that the inputs that are not part of any match are left unchanged.
The input object is left unchanged, because it is not a \textit{replacement}
function per se.

The operation is vectorised with respect to all the three arguments
(\textit{haystack}, \textit{needle}, \textit{replacement string}),
with the usual recycling behaviour if necessary.
If a different arguments' vectorisation scheme is required,
we can set the \code{vectorise_all} argument of \code{stri_replace_all()}
to \code{FALSE}.
Compare the following:

\begin{Schunk}
\begin{Sinput}
R> stri_replace_all_fixed("The quick brown fox jumped over the lazy dog.",
+    c("quick", "brown",      "fox", "lazy",    "dog"),
+    c("slow",  "yellow-ish", "hen", "spamity", "llama"))
\end{Sinput}
\begin{Soutput}
[1] "The slow brown fox jumped over the lazy dog."
[2] "The quick yellow-ish fox jumped over the lazy dog."
[3] "The quick brown hen jumped over the lazy dog."
[4] "The quick brown fox jumped over the spamity dog."
[5] "The quick brown fox jumped over the lazy llama."
\end{Soutput}
\begin{Sinput}
R> stri_replace_all_fixed("The quick brown fox jumped over the lazy dog.",
+    c("quick", "brown",      "fox", "lazy", "dog"),
+    c("slow",  "yellow-ish", "hen", "spamity", "llama"),
+    vectorise_all=FALSE)
\end{Sinput}
\begin{Soutput}
[1] "The slow yellow-ish hen jumped over the spamity llama."
\end{Soutput}
\end{Schunk}

\noindent
Here, for every string in the \textit{haystack}, we observe the vectorisation
\textit{independently} over the \textit{needles} and replacement strings.
Each occurrence of the 1st needle is superseded by the 1st replacement
string, then the search is repeated for the 2nd needle so as to replace
it with the 2nd corresponding replacement string, and so forth.

Moreover, \code{stri_replace_first()} and \code{stri_replace_last()}
can identify and replace the first and the last match, respectively.




\subsection{Splitting}

To  split each element in the \textit{haystack} into substrings,
where the \textit{needles} define the delimiters that separate
the inputs into tokens,
we call \code{stri\_split()}:

\begin{Schunk}
\begin{Sinput}
R> x <- c("a,b,c,d", "e", "", NA, "f,g,,,h,i,,j,")
R> stri_split_fixed(x, ",", omit_empty=TRUE)
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "a" "b" "c" "d"

[[2]]
[1] "e"

[[3]]
character(0)

[[4]]
[1] NA

[[5]]
[1] "f" "g" "h" "i" "j"
\end{Soutput}
\end{Schunk}

The result is a list of character vectors, as each string
in the \textit{haystack}
might be split into a possibly different number of tokens.

There is also an option to limit the number of tokens
(parameter \code{n}).


% stri_split_fixed(x, ",", n=3)  # stringr compatibility mode
% stri_split_fixed(x, ",", n=3, tokens_only=TRUE, omit_empty=TRUE)






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \clearpage

\section{Regular expressions}\label{Sec:regex}

Regular expressions (\textit{regex}es) provide us with a concise
grammar for defining systematic patterns which can be sought in character
strings. Examples of such patterns include:
% \begin{enumerate}
specific fixed substrings,
emojis of any kind,
stand-alone sequences of lower-case Latin letters (``words''),
substrings that can be interpreted as real numbers (with or without fractional part, also in scientific notation),
telephone numbers,
email addresses, or
URLs.
% \end{enumerate}

Theoretically, the concept of regular pattern matching
dates back to the so-called regular languages and finite state
automata \citep{kleene},
see also \citep{hopcroftullman,automata}.
Regexes in the form as we know today have already been present
in one of the pre-Unix implementations of the command-line text
editor \pkg{qed} (\citealp{qed}; the predecessor of the well-known \pkg{sed}).

Base  \proglang{R} gives access to two different regex matching engines
(via functions such as \code{gregexpr()} and \code{grep()},
see Table~\ref{Tab:oldstringr}):
\begin{itemize}
\item {ERE}\footnote{Via the \pkg{TRE} library
(\url{https://github.com/laurikari/tre/}).}
(\textit{extended regular expressions} that conform
to the POSIX.2-1992 standard);
used by default,
\item {PCRE}\footnote{Via the \pkg{PCRE2}
library (\url{https://www.pcre.org/}).}
(\textit{\proglang{Perl}-compatible regular expressions});
activated when \code{perl=TRUE} is set.
\end{itemize}
Other matchers are implemented in the \pkg{ore}
(\citealp{ore}; via the \pkg{Onigmo} library)
and \pkg{re2r} (\citealp{re2r}; \pkg{RE2}) packages.
% https://cran.r-project.org/web/packages/ore/index.html
% https://github.com/qinwf/re2r


\pkg{Stringi}, on the other hand, provides access to the regex engine
implemented in \pkg{ICU}, which was inspired
by \proglang{Java}'s \pkg{util.regex}
in \pkg{JDK 1.4}. Their syntax is mostly compatible with that of \pkg{PCRE},
although certain more advanced facets might not be supported (e.g., recursive
patters). On the other hand, \pkg{ICU} regexes fully conform to the
Unicode Technical Standard \#18 \citep{uts18:regex} and hence provide
comprehensive support for Unicode.


It is worth noting that most programming languages
as well as advanced text editors and IDEs (including
\pkg{Kate}, \pkg{Eclipse}, \pkg{VSCode}, and \pkg{RStudio})
support finding or replacing patters with regexes.
Therefore, they should be amongst the instruments
at every data scientist's disposal.
One general introduction to regexes is \citep{friedl}.
% Some general topics are also covered in the R manual, see \code{?regex}.
The \pkg{ICU} flavour is summarised at
\url{https://unicode-org.github.io/icu/userguide/strings/regexp.html}.






Below we provide a concise yet comprehensive introduction
to the topic from the perspective of the \pkg{stringi} package users.
This time we will use the pattern search routines whose names
end with the \code{*_regex()} suffix.
Apart from \code{stri_detect_regex()}, \code{stri_locate_all_regex()},
and so forth, in Section~\ref{Sec:Capturing} we introduce
\code{stri_match_all_regex()}.
Moreover, Table~\ref{Tab:regex_opts} lists the available options
for the regex engine.


% string search functions described in Section~\ref{Sec:fixed},




\begin{table}[t!]
\centering

\begin{tabularx}{1.0\linewidth}{p{4.6cm}X}
\toprule
\bfseries{Option}            &\bfseries Purpose \\
\midrule
\code{case\_insensitive}\newline
[regex flag \code{(?i)}] & logical; defaults to \code{FALSE}; whether to enable (full) case-insensitive matching  \\
\midrule
\code{comments}\newline
[regex flag \code{(?x)}] & logical; defaults to \code{FALSE}; whether to allow white spaces and comments within patterns  \\
\midrule
\code{dot\_all}\newline
[regex flag \code{(?s)}] & logical; defaults to \code{FALSE}; if set, ``\code{.}'' matches line terminators; otherwise its matching stops at a line end  \\
\midrule
\code{literal} & logical; defaults to \code{FALSE}; whether to treat the entire pattern as a literal string; note that in most cases the code-pointwise string search facilities
(\code{*\_fixed()} functions described in Section~\ref{Sec:fixed}) are faster
\\
\midrule
\code{multi\_line}\newline
[regex flag \code{(?m)}] & logical; defaults to \code{FALSE}; if set, ``\code{\$}'' and ``\code{\textasciicircum}'' recognise line terminators within a string; otherwise, they match only at start and end of the input \\
\midrule
\code{unix\_lines} & logical; defaults to \code{FALSE}; when enabled, only the Unix line ending, i.e., U+000A, is honoured as a terminator by ``\code{.}'', ``\code{\$}'', and ``\code{\textasciicircum}''\\
\midrule
\code{uword}\newline
[regex flag \code{(?w)}] & logical; defaults to \code{FALSE}; whether to use the Unicode definition of word boundaries (see Section~\ref{Sec:BoundaryAnalysis}), which are quite different from the traditional regex word boundaries\\
\midrule
\code{error\_on\_unknown\_escapes} & logical; defaults to \code{FALSE}; whether unrecognised backslash-escaped characters trigger an error; by default,  unknown backslash-escaped ASCII letters represent themselves \\
\midrule
\code{time\_limit} & integer; processing time limit for match operations in $\sim$milliseconds
(depends on the CPU speed);
0 for no limit (the default) \\
\midrule
\code{stack\_limit} & integer; maximal size, in bytes, of the heap storage available
for the matcher's backtracking stack; setting a limit is desirable if poorly
written regexes are expected on input; 0 for no limit (the default) \\
\bottomrule
\end{tabularx}

\caption{\label{Tab:regex_opts} Options for the regular expressions
search engine, see \code{stri\_opts\_regex()}.}
\end{table}



\subsection{Matching individual characters}\label{Sec:RegexIndividualChars}

We begin by discussing different ways to define character sets.
In this part, determining the length of all matching substrings
will be quite straightforward.

The following characters have special
meaning to the regex engine:
\[
\text{
  \texttt{.}\quad
  \textbackslash{}\quad
  \texttt{|}\quad
  \texttt{(}\quad
  \texttt{)}\quad
  \texttt{[}\quad
%    \texttt{]}
  \texttt{\{}\quad
  \texttt{\}}\quad
  \texttt{\^{}}\quad
  \texttt{\$}\quad
  \texttt{*}\quad
  \texttt{+}\quad
  \texttt{?}\quad
}
\]

Any regular expression that does not contain the above
behaves like a fixed pattern:

\begin{Schunk}
\begin{Sinput}
R> stri_count_regex("spam, eggs, spam, bacon, sausage, and spam", "spam")
\end{Sinput}
\begin{Soutput}
[1] 3
\end{Soutput}
\end{Schunk}

There are hence 3 occurrences of a pattern that is comprised
of 4 code points, ``\code{s}'' followed by ``\code{p}'',
then by ``\code{a}'', and ending with ``\code{m}''.

However, this time the case insensitive mode fully
supports Unicode matching\footnote{%
This does not mean, though, that it considers canonically
equivalent strings as equal,
see Section~\ref{Sec:Equivalence} for a discussion and a workaround.}:
% matching strings may be of different lengths.
% stri_detect_regex("a\u0328", "ą")
% stri_detect_regex("ą", "a\u0328")

\begin{Schunk}
\begin{Sinput}
R> stri_detect_regex("groß", "GROSS", case_insensitive=TRUE)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}

If we wish to include a special character as part of a regular expression --
so that it is treated literally -- we will need to escape it with  a backslash,
``\textbackslash''. Yet, the backlash itself
has a special meaning to \proglang{R}, see \code{help("Quotes")},
therefore it needs to be preceded by another backslash.

\begin{Schunk}
\begin{Sinput}
R> stri_count_regex("spam...", "\\.")   # "\\" is a way to input a single \
\end{Sinput}
\begin{Soutput}
[1] 3
\end{Soutput}
\end{Schunk}

In other words, the \proglang{R} string \code{"\textbackslash\textbackslash."}
is seen by the regex engine as ``\code{\textbackslash.}'' and interpreted
as the dot character (literally). Alternatively,
since R 4.0 we can also input the so-called literal strings
like \code{r"(\textbackslash.)"}.


\paragraph{Matching any character.}
The (unescaped) dot, ``\code{.}'', matches any code point except the newline.

\begin{Schunk}
\begin{Sinput}
R> x <- "Ham, spam,\njam, SPAM, eggs, and spam"
R> stri_extract_all_regex(x, "..am", case_insensitive=TRUE)
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "spam" "SPAM" "spam"
\end{Soutput}
\end{Schunk}

The above matches non-overlapping length-4 substrings that
end with ``\code{am}''.

The dot's insensitivity to the newline character is motivated
by the need to maintain the compatibility with tools such as \pkg{grep}
(when searching within text files in a line-by-line manner).
This behaviour can be altered by setting the \code{dot_all} option to \code{TRUE}.

\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex(x, "..am", dot_all=TRUE, case_insensitive=TRUE)
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "spam"  "\njam" "SPAM"  "spam"
\end{Soutput}
\end{Schunk}



\paragraph{Defining character sets.}
Sets of characters can be introduced by enumerating
their members within a pair of
square brackets.
For instance, ``\code{[abc]}'' denotes the set $\{\mathtt{a},\mathtt{b},\mathtt{c}\}$
-- such a regular expression matches one (and only one) symbol from this set.
Moreover, in:


\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex(x, "[hj]am")
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "jam"
\end{Soutput}
\end{Schunk}


\noindent
the ``\code{[hj]am}'' regex matches:
``\code{h}'' or ``\code{j}'', followed by ``\code{a}'', followed by ``\code{m}''.
In other words, \code{"ham"} and \code{"jam"}
are the only two strings that are matched by this pattern
(unless matching is done case-insensitively).


% \begin{wazne}
The following characters, if used within square brackets, may be treated
non-literally:
\[
\text{
  \textbackslash{}\quad
  \texttt{[}\quad
  \texttt{]}\quad
  \texttt{\^{}}\quad
  \texttt{{}-{}}\quad
  \texttt{\&}\quad
}
\]
Therefore, to include them as-is in a character set, the
backslash-escape must be used.
For example, ``\code{[\textbackslash[\textbackslash]\textbackslash\textbackslash]}'' matches
the backslash or a square bracket.

\paragraph{Complementing sets.}
Including ``\code{\^{}}'' after the opening square bracket denotes the set complement.
Hence, ``\code{[\^{}abc]}'' matches any code point except ``\code{a}'',
``\code{b}'', and ``\code{c}''.
Here is an example where we seek any substring that consists of 3 non-spaces.

\begin{Schunk}
\begin{Sinput}
R> x <- "Nobody expects the Spanish Inquisition!"
R> stri_extract_all_regex(x, "[^ ][^ ][^ ]")
\end{Sinput}
\begin{Soutput}
[[1]]
 [1] "Nob" "ody" "exp" "ect" "the" "Spa" "nis" "Inq" "uis" "iti" "on!"
\end{Soutput}
\end{Schunk}



\paragraph{Defining Code Point Ranges.}
Each Unicode code point can be referenced by its unique numeric identifier,
see Section~\ref{Sec:codepoints}  for more details.
For instance, ``\code{a}'' is assigned code U+0061 and ``\code{z}'' is mapped to U+007A.
In the pre-Unicode era (mostly with regards to the ASCII codes, $\le$ U+007F,
representing English letters, decimal digits, some punctuation characters,
and a few control characters),
we were used to relying on specific code ranges; e.g.,
``\code{[a-z]}'' denotes the set comprised of all
characters with codes between U+0061 and U+007A, i.e., lowercase letters
of the English (Latin) alphabet.

\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex("In 2020, Gągolewski had fun once.", "[0-9A-Za-z]")
\end{Sinput}
\begin{Soutput}
[[1]]
 [1] "I" "n" "2" "0" "2" "0" "G" "g" "o" "l" "e" "w" "s" "k" "i" "h" "a" "d"
[19] "f" "u" "n" "o" "n" "c" "e"
\end{Soutput}
\end{Schunk}

% And it was awful :)


The above pattern denotes a union of 3 code ranges:
digits and ASCII upper- and lowercase letters.

Nowadays, in the processing of text in natural languages, this
notation should rather be avoided. Note the missing ``\code{ą}''
(Polish ``\code{a}'' with ogonek) in the result.


\paragraph{Using predefined character sets.}
Each code point is assigned a unique \textit{general category},
which can be thought of as a character's class,
see \citep{usa44:ucd}.
Sets of characters from each category can be referred to,
amongst others, by using the ``\code{\textbackslash{}p\{category\}}''
(or, equivalently, ``\code{[\textbackslash{}p\{category\}]}'') syntax:

% \begin{CJK*}{UTF8}{bsmi}
\begin{Schunk}
\begin{Sinput}
R> x <- "aąbßÆAĄB你123,.;'! \t-+=[]©←→”„²³¾"
R> p <- c("\\p{L}", "\\p{Ll}", "\\p{Lu}", "\\p{N}", "\\p{P}", "\\p{S}")
R> structure(stri_extract_all_regex(x, p), names=p)
\end{Sinput}
\begin{Soutput}
$`\\p{L}`
[1] "a"  "ą"  "b"  "ß"  "Æ"  "A"  "Ą"  "B"  "你"

$`\\p{Ll}`
[1] "a" "ą" "b" "ß"

$`\\p{Lu}`
[1] "Æ" "A" "Ą" "B"

$`\\p{N}`
[1] "1" "2" "3" "²" "³" "¾"

$`\\p{P}`
 [1] "," "." ";" "'" "!" "-" "[" "]" "”" "„"

$`\\p{S}`
[1] "+" "=" "©" "←" "→"
\end{Soutput}
\end{Schunk}
% \end{CJK*}

The above yield a match to: arbitrary letters, lowercase letters, uppercase letters,
numbers, punctuation marks, and symbols, respectively.

% stri_extract_all_regex(x, "\\p{L}")   # letter (equivalently: [\p{L}])
% stri_extract_all_regex(x, "\\p{Ll}")  # lowercase letter
% stri_extract_all_regex(x, "\\p{Lu}")  # uppercase letter
% stri_extract_all_regex(x, "\\p{N}")   # number
% stri_extract_all_regex(x, "\\p{P}")   # punctuation
% stri_extract_all_regex(x, "\\p{S}")   # symbol

Characters' binary properties and scripts can also be referenced in a similar manner.
Some other noteworthy classes include:

% \begin{CJK*}{UTF8}{bsmi}
\begin{Schunk}
\begin{Sinput}
R> p <- c("\\w", "\\d", "\\s")
R> structure(stri_extract_all_regex(x, p), names=p)
\end{Sinput}
\begin{Soutput}
$`\\w`
 [1] "a"  "ą"  "b"  "ß"  "Æ"  "A"  "Ą"  "B"  "你" "1"  "2"  "3"

$`\\d`
[1] "1" "2" "3"

$`\\s`
[1] " "  "\t"
\end{Soutput}
\end{Schunk}
% \end{CJK*}

These give: word characters, decimal digits (``\code{\textbackslash{}p\{Nd\}}''),
and spaces (``\code{[\textbackslash{}t\textbackslash{}n\textbackslash{}f\textbackslash{}r\textbackslash{}p\{Z\}]}''),
in this order.

Moreover, e.g., the upper-cased ``\code{\textbackslash{}P\{category\}}'' and
``\code{\textbackslash{}W}'' are equivalent to
``\code{[\^{}\textbackslash{}p\{category\}]}'' and
``\code{[\^{}\textbackslash{}w]}'', respectively, i.e.,
denote their complements.


% stri_extract_all_regex(z, "\\p{WHITE_SPACE}") # spaces (Unicode property)


\paragraph{Avoiding POSIX classes.}
The use of the POSIX-like character classes should be avoided,
because they are generally not well-defined.

In particular, in POSIX-like regex engines, ``\code{[:punct:]}''
stands for the character class corresponding to the \code{ispunct()}
function in \proglang{C} (see ``\code{man 3 ispunct}'' on Unix-like systems).
According to ISO/IEC 9899:1990 (ISO C90), \code{ispunct()} tests for
any printing character except for the space or a character for which \code{isalnum()}
is true.

Base \proglang{R} with \pkg{PCRE} yields on the current
author's machine:

\begin{Schunk}
\begin{Sinput}
R> x <- ",./|\\<>?;:'\"[]{}-=_+()*&^%$€#@!`~×‒„”"
R> regmatches(x, gregexpr("[[:punct:]]",  x, perl=TRUE))  # base R
\end{Sinput}
\begin{Soutput}
[[1]]
 [1] ","  "."  "/"  "|"  "\\" "<"  ">"  "?"  ";"  ":"  "'"  "\"" "["  "]"
[15] "{"  "}"  "-"  "="  "_"  "+"  "("  ")"  "*"  "&"  "^"  "%"  "$"  "#"
[29] "@"  "!"  "`"  "~"
\end{Soutput}
\end{Schunk}

% stri_sub(x, gregexpr("[^[:punct:]]", x, perl=TRUE)[[1]], length=1)

However, the details of the characters' belongingness
to this class depend on the current locale.
Therefore, the reader might obtain different results when calling the above.

\pkg{ICU}, on the other hand, always gives:

\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex(x, "[[:punct:]]")    # equivalently: \p{P}
\end{Sinput}
\begin{Soutput}
[[1]]
 [1] ","  "."  "/"  "\\" "?"  ";"  ":"  "'"  "\"" "["  "]"  "{"  "}"  "-"
[15] "_"  "("  ")"  "*"  "&"  "%"  "#"  "@"  "!"  "‒"  "„"  "”"
\end{Soutput}
\begin{Sinput}
R> stri_extract_all_regex(x, "\\p{S}")         # symbols
\end{Sinput}
\begin{Soutput}
[[1]]
 [1] "|" "<" ">" "=" "+" "^" "$" "€" "`" "~" "×"
\end{Soutput}
\end{Schunk}

% stri_extract_all_regex(x, "[^[:punct:]]")   # complement

We strongly recommend, wherever possible, the use of the portable
``\code{[\textbackslash{}p\{P\}\textbackslash{}p\{S\}]}''
as an alternative to the \pkg{PCRE}'s ``\code{[:punct:]}''.



\subsection{Alternating and grouping subexpressions}

The alternation operator, ``\code{|}'',
matches either its left or its right branch,
for instance:

\begin{Schunk}
\begin{Sinput}
R> x <- "spam, egg, ham, jam, algae, and an amalgam of spam, all al dente"
R> stri_extract_all_regex(x, "spam|ham")
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "spam" "ham"  "spam"
\end{Soutput}
\end{Schunk}

``\code{|}'' has a very low precedence. Therefore, if we wish to
introduce an alternative of \textit{sub}expressions,
we need to group them, e.g., between round brackets\footnote{Which have
the side-effect of creating new capturing groups, see below for a discussion.}.
For instance, ``\code{(sp|h)am}'' matches either
``\code{spam}'' or ``\code{ham}''.

Also, matching is always done left-to-right, on a first-come, first-served basis.
Hence, if the left branch is a subset of the right one, the latter will
never be matched.
In particular, ``\code{(al|alga|algae)}'' can only match ``\code{al}''.
To fix this, we can write ``\code{(algae|alga|al))}''.


\paragraph{Non-grouping parentheses.}
Some parenthesised subexpressions -- those in which the opening bracket is followed by the question mark -- have a distinct meaning.
In particular, ``\code{(?\#...)}'' denotes a free-format comment
that is ignored by the regex parser:

\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex(x,
+    "(?# match 'sp' or 'h')(sp|h)(?# and 'am')am|(?# or match 'egg')egg")
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "spam" "egg"  "ham"  "spam"
\end{Soutput}
\end{Schunk}

\noindent
Nevertheless, constructing more sophisticated regexes by concatenating
subfragments thereof may sometimes be more readable:

\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex(x,
+    stri_join(
+        "(sp|h)",   # match either 'sp' or 'h'
+        "am",       # followed by 'am'
+      "|",            # ... or ...
+        "egg"       # just match 'egg'
+  ))
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "spam" "egg"  "ham"  "spam"
\end{Soutput}
\end{Schunk}


What is more, e.g., ``\code{(?i)}'' enables the \code{case\_insensitive}
mode.

\begin{Schunk}
\begin{Sinput}
R> stri_count_regex("Spam spam SPAMITY spAm", "(?i)spam")
\end{Sinput}
\begin{Soutput}
[1] 4
\end{Soutput}
\end{Schunk}

For more regex flags, we kindly refer the reader to Table~\ref{Tab:regex_opts} again.




\subsection{Quantifiers}

More often than not, a variable number of
instances of the same subexpression needs to be captured
or its presence should be made optional.
This can be achieved by means of the following quantifiers:
\begin{itemize}
\item ``\code{?}'' matches 0 or 1 times,
\item ``\code{*}'' matches 0 or more times,
\item ``\code{+}'' matches 1 or more times,
\item ``\code{\{n,m\}}'' matches between \code{n} and \code{m} times,
\item ``\code{\{n,\}}'' matches at least \code{n} times,
\item ``\code{\{n\}}'' matches exactly \code{n} times.
\end{itemize}
These operators are applied to the preceding atoms.
For example, ``\code{ba+}'' captures
\code{"ba"}, \code{"baa"}, \code{"baaa"}, etc., but not \code{"b"} alone.


By default, the quantifiers are \textit{greedy} -- they match the
repeated subexpression as many times as possible. The ``\code{?}'' suffix
(hence, quantifiers such as ``\code{??}'', ``\code{*?}'', ``\code{+?}'', and so forth) tries with
as few occurrences as possible (to obtain a match still).


\begin{Schunk}
\begin{Sinput}
R> x <- "sp(AM)(maps)(SP)am"
R> stri_extract_all_regex(x,
+    c("\\(.+\\)",    # [[1]] greedy
+      "\\(.+?\\)",   # [[2]] lazy
+      "\\([^)]+\\)"  # [[3]] greedy (but clever)
+  ))
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "(AM)(maps)(SP)"

[[2]]
[1] "(AM)"   "(maps)" "(SP)"

[[3]]
[1] "(AM)"   "(maps)" "(SP)"
\end{Soutput}
\end{Schunk}

The first regex is greedy: it matches an opening bracket,
then as many characters as possible (including ``\code{)}'')
that are followed by a closing bracket.
The two other patterns terminate as soon as the first closing
bracket is found.

\ifnotJSSversion
\begin{Schunk}
\begin{Sinput}
R> stri_extract_first_regex("spamamamnomnomnomammmmmmmmm",
+    c("sp(am|nom)+",             "sp(am|nom)+?",
+      "sp(am|nom)+?m*",          "sp(am|nom)+?m+"))
\end{Sinput}
\begin{Soutput}
[1] "spamamamnomnomnomam"         "spam"
[3] "spam"                        "spamamamnomnomnomammmmmmmmm"
\end{Soutput}
\end{Schunk}
\fi


Let us stress that the quantifier is applied to the subexpression
that stands directly before it. Grouping parentheses can be used in case
they are needed.

\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex("12, 34.5, 678.901234, 37...629, ...",
+    c("\\d+\\.\\d+", "\\d+(\\.\\d+)?"))
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "34.5"       "678.901234"

[[2]]
[1] "12"         "34.5"       "678.901234" "37"         "629"
\end{Soutput}
\end{Schunk}

Here, the first regex matches digits, a dot, and another series of digits.
The second one finds digits which are possibly (but not necessarily)
followed by a dot and a digit sequence.





\paragraph{Performance notes.}
\pkg{ICU}, just like \pkg{PCRE}, uses a nondeterministic finite automaton-type
algorithm. Hence, due to backtracking, some ill-defined regexes can lead to
exponential matching times (e.g., ``\code{(a+)+b}'' applied on \code{"aaaa...aaaaac"}).
If such patterns are expected, setting the \code{time\_limit} or \code{stack\_limit}
option is recommended.

\begin{Schunk}
\begin{Sinput}
R> system.time(tryCatch({
+    stri_detect_regex("a" %s*% 1000 %s+% "c", "(a+)+b", time_limit=1e5)
+  }, error=function(e) cat("stopped.")))
\end{Sinput}
\begin{Soutput}
stopped.
\end{Soutput}
\begin{Soutput}
   user  system elapsed
 17.892   0.000  17.900
\end{Soutput}
\end{Schunk}


Nevertheless, oftentimes such regexes can be naturally
reformulated to  fix the underlying issue.
The \pkg{ICU} User Guide on Regular Expressions also recommends using
\textit{possessive quantifiers} (``\code{?+}'', ``\code{*+}'', ``\code{++}'', and so on),
which match as many times as possible but, contrary to
the plain-greedy ones, never backtrack when they happen to consume too much data.

See also the \pkg{re2r} (a wrapper around the \pkg{RE2} library;
\citealp{re2r}) package's
documentation and the references therein for a discussion.




\subsection{Capture groups and references thereto}\label{Sec:Capturing}

Round-bracketed subexpressions carry one additional
characteristic: they form the so-called \textit{capture groups} that can
be extracted separately or be referred to in other parts of the same regex.




\paragraph{Extracting capture group matches.}
The above is evident when we use the
versions of \code{stri\_extract()} that are sensitive to the presence
of capture groups:


\begin{Schunk}
\begin{Sinput}
R> x <- "name='Sir Launcelot', quest='Seek the Grail', favecolour='blue'"
R> stri_match_all_regex(x, "(\\w+)='(.+?)'")
\end{Sinput}
\begin{Soutput}
[[1]]
     [,1]                     [,2]         [,3]
[1,] "name='Sir Launcelot'"   "name"       "Sir Launcelot"
[2,] "quest='Seek the Grail'" "quest"      "Seek the Grail"
[3,] "favecolour='blue'"      "favecolour" "blue"
\end{Soutput}
\end{Schunk}

The findings are presented in a matrix form. The first column
gives the complete matches, the second column stores the matches to the
first capture group, and so forth.
% this was introduced in string
% base R regmatches return a transposed version of these


If we just need the grouping part of ``\code{(...)}'', i.e.,
without the capturing feature,
``\code{(?:...)}'' can be applied.
Also, named capture groups defined like
``\code{(?<name>...)}'' are fully supported
since version 1.7.1 of our package (for historical notes see
\citealp{namedCapture}).

\begin{Schunk}
\begin{Sinput}
R> stri_match_all_regex(x, "(?:\\w+)='(?<value>.+?)'")
\end{Sinput}
\begin{Soutput}
[[1]]
                              value
[1,] "name='Sir Launcelot'"   "Sir Launcelot"
[2,] "quest='Seek the Grail'" "Seek the Grail"
[3,] "favecolour='blue'"      "blue"
\end{Soutput}
\end{Schunk}



\paragraph{Locating capture group matches.}
The \code{capture_groups} attribute in \code{stri_locate_*_regex}
enables us to pinpoint the matches to the parenthesised subexpressions
as well:

\begin{Schunk}
\begin{Sinput}
R> stri_locate_all_regex(x, "(?<key>\\w+)='(?<value>.+?)'",
+    capture_groups=TRUE, get_length=TRUE)
\end{Sinput}
\begin{Soutput}
[[1]]
     start length
[1,]     1     20
[2,]    23     22
[3,]    47     17
attr(,"capture_groups")
attr(,"capture_groups")$key
     start length
[1,]     1      4
[2,]    23      5
[3,]    47     10

attr(,"capture_groups")$value
     start length
[1,]     7     13
[2,]    30     14
[3,]    59      4
\end{Soutput}
\end{Schunk}

\noindent
Note that each item in the resulting list
is equipped with a \code{"capture_groups"} attribute.
For instance,
\code{attr(result[[1]], "capture_groups")[[2]]}
extracts the locations of the matches to the 2nd capture group
in the first input string.

\paragraph{Replacing with capture group matches.}
Matches to particular capture groups can be recalled in replacement strings
when using \code{stri\_replace()}.
Here, the match in its entirety is denoted with ``\code{\$0}'',  then
``\code{\$1}'' stores whatever was caught by the first capture group,
``\code{\$2}'' is the match to the second capture group, etc.
Moreover, ``\code{\textbackslash{}\$}'' gives the dollar-sign.


\begin{Schunk}
\begin{Sinput}
R> stri_replace_all_regex(x, "(\\w+)='(.+?)'", "$2 is a $1")
\end{Sinput}
\begin{Soutput}
[1] "Sir Launcelot is a name, Seek the Grail is a quest, blue is a favecolour"
\end{Soutput}
\end{Schunk}

Named capture groups can be referred to too:

\begin{Schunk}
\begin{Sinput}
R> stri_replace_all_regex(x, "(?<key>\\w+)='(?<value>.+?)'",
+    "${value} is a ${key}")
\end{Sinput}
\begin{Soutput}
[1] "Sir Launcelot is a name, Seek the Grail is a quest, blue is a favecolour"
\end{Soutput}
\end{Schunk}

\paragraph{Back-referencing.}
Matches to capture groups can also be part of the regexes themselves.
For example, ``\code{\textbackslash{}1}'' denotes whatever
has been consumed by the first capture group.

Even though, in general, parsing \proglang{HTML} code with regexes is
not recommended, let us consider the following examples:

\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex("<strong><em>spam</em></strong><code>eggs</code>",
+    c("<[a-z]+>.*?</[a-z]+>", "<([a-z]+)>.*?</\\1>"))
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "<strong><em>spam</em>" "<code>eggs</code>"

[[2]]
[1] "<strong><em>spam</em></strong>" "<code>eggs</code>"
\end{Soutput}
\end{Schunk}

% stri_extract_all_regex(x, "<(?<tag>[a-z]+)>.*?</\\k<tag>>")

The second regex guarantees that the match will include all characters
between the opening \code{<tag>} and the \textit{corresponding} (not: any)
closing \code{</tag>}.
Named capture groups can be referenced using the
\code{\textbackslash{}k<name>} syntax
(the angle brackets are part of the token), as in, e.g.,
``\code{<(?<tagname>[a-z]+)>.*?</\textbackslash{}k<tagname>>}''.


% \bigskip DONE-implemented
% On a side note, currently \pkg{ICU} does not support the extraction
% of names of named capture groups, see however \citep{namedCapture}
% for a discussion.



\subsection{Anchoring}

Lastly, let us mention the ways to match a pattern
at a given abstract position within a string.

\paragraph{Matching at the beginning or end of a string.}
``\code{\^{}}'' and ``\code{\$}''  match, respectively,
start and end of the string
(or each line within a string, if the \code{multi_line} option is set to \code{TRUE}).

\begin{Schunk}
\begin{Sinput}
R> x <- c("spam egg", "bacon spam", "spam", "egg spam bacon", "sausage")
R> p <- c("spam", "^spam", "spam$", "spam$|^spam", "^spam$")
R> structure(outer(x, p, stri_detect_regex), dimnames=list(x, p))
\end{Sinput}
\begin{Soutput}
                spam ^spam spam$ spam$|^spam ^spam$
spam egg        TRUE  TRUE FALSE        TRUE  FALSE
bacon spam      TRUE FALSE  TRUE        TRUE  FALSE
spam            TRUE  TRUE  TRUE        TRUE   TRUE
egg spam bacon  TRUE FALSE FALSE       FALSE  FALSE
sausage        FALSE FALSE FALSE       FALSE  FALSE
\end{Soutput}
\end{Schunk}

The 5 regular expressions match ``\code{spam}'', respectively,
anywhere within the string, at the beginning,
at the end, at the beginning or end,
and in strings that are equal to the pattern itself.

% stri_detect_regex(x, "spam")           # 'spam' wherever
% stri_detect_regex(x, "^spam")          # begins with 'spam'
% stri_detect_regex(x, "spam$")          # ends with 'spam'
% stri_detect_regex(x, "spam$|^spam")    # begins or ends with 'spam'
% stri_detect_regex(x, "^spam$")         # 'spam' only


\paragraph{Matching at word boundaries.}
Furthermore, ``\code{\textbackslash{}b}'' matches
at a ``word boundary``, e.g., near spaces, punctuation marks,
or at the start/end of a string (i.e., wherever there is a transition
between a word, ``\code{\textbackslash{}w}'', and a non-word character,
``\code{\textbackslash{}W}'', or vice versa).

In the following example, we match
all stand-alone numbers\footnote{This regular expression
is provided for didactic purposes only.}:


\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex("12, 34.5, J23, 37.629cm", "\\b\\d+(\\.\\d+)?+\\b")
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "12"   "34.5"
\end{Soutput}
\end{Schunk}

Note the possessive quantifier, ``\code{?+}'':
try matching a dot and a sequence of digits,
and if it is present but not followed by a word boundary,
do not retry by matching a word boundary only.



\paragraph{Looking behind and ahead.}
There are also ways to guarantee that a pattern occurrence
begins or ends with a match to some subexpression:
``\code{(?<=...)...}'' is the so-called  \textit{look-behind}, whereas
``\code{...(?=...)}'' denotes the \textit{look-ahead}.
Moreover, ``\code{(?<!...)...}'' and ``\code{...(?!...)}'' are
their negated (``negative look-behind/ahead'') versions.



\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_regex("I like spam, spam, eggs, and spam.",
+    c("\\w+(?=[,.])", "\\w++(?![,.])"))
\end{Sinput}
\begin{Soutput}
[[1]]
[1] "spam" "spam" "eggs" "spam"

[[2]]
[1] "I"    "like" "and"
\end{Soutput}
\end{Schunk}

The first regex captures words that end with ``\code{,}'' or ``\code{.}''.
The second one matches words that end neither with ``\code{,}'' nor ``\code{.}''.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Collation}\label{Sec:collator}



Historically, code-pointwise comparison had been used in most string comparison
activities, especially when strings in ASCII (i.e., English) were
involved. However, nowadays %(in the ``Internet era'')
this does not necessarily constitute the most suitable
approach to the processing of natural-language texts.
In particular, a code-pointwise matching
neither takes accented and conjoined letters nor ignorable punctuation and case
into account.
% see Section~\ref{Sec:collator} for more details and an NLP-aware solution.



The \pkg{ICU} Collation Service\footnote{See the \pkg{ICU} User Guide on {Collation},
\url{https://unicode-org.github.io/icu/userguide/collation/}.}
provides the basis for string comparison activities  such as
string sorting and searching, or determining if two strings are equivalent.
This time, though, due to its conformance to
the Unicode Collation Algorithm \citep{uts10:collation},
% (see also ISO/IEC 14651:2016),
we may expect that the generated results
will meet the requirements of the culturally correct
natural language processing in any \textit{locale}.





\subsection{Locales}

String collation is amongst many locale-sensitive operations  available
in \pkg{stringi}. Before proceeding any further, we should
first discuss how we can parameterise the \pkg{ICU} services
so as to deliver the results that reflect the expectations
of a specific user community, such as the speakers of different languages
and their various regional variants.

\paragraph{Specifying locales.}
A locale specifier\footnote{%
Locale specifiers in \pkg{ICU} are platform-independent.
This is not the case for their base-\proglang{R} counterparts, see
\code{help("locales")}, e.g., we have \code{"Polish\_Poland"} on Windows
vs~\code{"pl\_PL"} on Linux.}
is of the form
\code{"Language"}, \code{"Language_Country"}, or \code{"Language_Country_Variant"},
where:
\begin{itemize}
\item
\code{Language} is, most frequently, a two- or three-letter code that conforms to
the ISO-639-1 or ISO-630-2 standard, respectively;
e.g., \code{"en"} or \code{"eng"} for English, \code{"es"} or \code{"spa"}
for Spanish, \code{"zh"} or \code{"zho"} for Chinese, and \code{"mas"} for Masai
(which lacks the corresponding two-letter code);
however, more specific language identifiers may also be
available, e.g., \code{"zh_Hans"} for Simplified-
and \code{"zh_Hant"} for Traditional-Chinese
or \code{"sr_Cyrl"} for Cyrillic- and \code{"sr_Latn"} for Latin-Serbian;


\item
\code{Country} is a two-letter code following the ISO-3166 standard
that enables different language conventions within the same language;
e.g., the US-English (\code{"en_US"}) and Australian-English (\code{"en_AU"})
not only observe some differences in spelling and vocabulary but also
in the units of measurement;

\item
\code{Variant} is an identifier indicating a preference towards
some convention within the same country; e.g., \code{"de_DE_PREEURO"}
formats currency values using the pre-2002 Deutsche Mark (DEM).
\end{itemize}
Moreover,  following the
``\code{@}'' symbol, semicolon-separated ``\code{key=value}'' pairs
can be appended to the locale specifier, in order to
customise some locale-sensitive services even further
(see below for an example using ``\code{@collation=phonebook}''
and Section~\ref{Sec:datetime} for ``\code{@calendar=hebrew}'', amongst others).


{\color{red}

}
%
% (GNU/Linux)	pl_PL.iso-8859-2
% (GNU/Linux)	Polish_Poland.1250
%





\paragraph{Listing locales.}
To list the available locale identifiers, we call \code{stri_locale_list()}.

\begin{Schunk}
\begin{Sinput}
R> length(stri_locale_list())
\end{Sinput}
\begin{Soutput}
[1] 784
\end{Soutput}
\end{Schunk}

\noindent
As the number of supported locales is very high, here we shall
display only 5 randomly chosen ones:

\begin{Schunk}
\begin{Sinput}
R> sample(stri_locale_list(), 5)
\end{Sinput}
\begin{Soutput}
[1] "nl_CW"      "pt_CH"      "ff_Latn_SL" "en_PH"      "en_HK"
\end{Soutput}
\end{Schunk}



\paragraph{Querying for locale-specific services.}
The availability of locale-specific services can only be determined during
the request for a particular resource\footnote{For more details,
see the \pkg{ICU} User Guide on {Locales},
\url{https://unicode-org.github.io/icu/userguide/locale/}.},
which may depend on the \pkg{ICU} library version
actually in use as well as the way the \pkg{ICU} Data Library (\pkg{icudt})
has been packaged. Therefore, for maximum portability,
it is best to rely on the \pkg{ICU} library bundle that
is shipped with \pkg{stringi}.
This is the case on Windows and macOS, whose users typically download the
pre-compiled versions of the package from CRAN.
However, on various flavours of GNU/Linux and other Unix-based systems,
the system \pkg{ICU} is used more eagerly\footnote{
See, e.g., software packages
\code{libicu-dev} on Debian/Ubuntu or \code{libicu-devel} on RHL/Fedora/OpenSUSE.
For more details regarding the configure/build process of \pkg{stringi},
refer to the \code{INSTALL} file.}.
To force building \pkg{ICU} from sources, we may call:

\begin{Schunk}
\begin{Sinput}
R> install.packages("stringi", configure.args="--disable-pkg-config")
\end{Sinput}
\end{Schunk}

Overall, if a requested service is unavailable
in a given locale, the best possible match is returned.


\paragraph{Default locale.}
Each locale-sensitive operation in \pkg{stringi} selects the \textit{current
default locale} if no locale has been explicitly requested,
i.e., when a function's \code{locale} argument (see Table~\ref{Tab:collator_opts})
is left alone in its ``\code{NULL}'' state.
The default locale is initially set to match the system locale on the current
platform, and may be changed with \code{stri_locale_set()}, e.g.,
in the very rare case of improper automatic locale detection.

As we have stated in the introduction, in this paper we use:

\begin{Schunk}
\begin{Sinput}
R> stri_locale_get()
\end{Sinput}
\begin{Soutput}
[1] "en_AU"
\end{Soutput}
\end{Schunk}

\noindent
i.e., the Australian-English locale
(which formats dates like ``17 July 2021'' and
uses metric units of measurement).

% locales in base R -- very problematic
%
% Sys.getlocale
%
% Sys.setlocale
%
% no per-call basis
%
% might be not installed
%
% different identifiers on Windows







\subsection{Testing string equivalence}\label{Sec:Equivalence}



% Canonical and Compatibility Equivalence -> https://unicode.org/reports/tr15/
In Unicode, some characters may have multiple representations.
For instance, ``LATIN SMALL LETTER A WITH OGONEK'' (``ą'') can be stored
as a single code point U+0105 or as a sequence
that is comprised of the letter ``LATIN SMALL LETTER A'', U+0061, and
the ``{COMBINING OGONEK}'', U+0328 (when rendered properly, they
should appear as if they were identical glyphs).
This is an example of \textit{canonical equivalence} of strings.

Testing for the Unicode equivalence between strings
can be performed by calling \code{\%s==\%} and, more generally,
\code{stri\_cmp\_equiv()}, or their negated versions,
\code{\%s!=\%} and \code{stri\_cmp\_nequiv()}.

\begin{Schunk}
\begin{Sinput}
R> "a\u0328" %s==% "ą"             # a, ogonek == a with ogonek
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}

% stri_cmp_equiv("a\u0328", "ą")  # the same


There are also functions for removing and indicating
duplicated elements in a character vector:

\begin{Schunk}
\begin{Sinput}
R> x <- c("Gągolewski", "Gagolewski", "Ga\u0328golewski")
R> stri_unique(x)
\end{Sinput}
\begin{Soutput}
[1] "Gągolewski" "Gagolewski"
\end{Soutput}
\begin{Sinput}
R> stri_duplicated(x)  # from_last=FALSE
\end{Sinput}
\begin{Soutput}
[1] FALSE FALSE  TRUE
\end{Soutput}
\end{Schunk}

Moreover, \code{stri_duplicated_any()}
returns the index of the first non-unique element.






\subsection{Linear ordering of strings}


% https://www.elastic.co/guide/en/elasticsearch/guide/current/sorting-collations.html

Operators such that \code{\%s<\%}, \code{\%<=\%}, etc.,
and the corresponding functions
\code{stri_cmp_lt()} (``less than''),
\code{stri_cmp_le()} (``less than or equal''), etc.,
implement locale-sensitive linear orderings of strings.
Moreover, \code{stri_sort()} returns the lexicographically-sorted
version of a given input vector, \code{stri_order()} yields
the corresponding (stable) ordering permutation,
and \code{stri_rank()} ranks strings within a vector.


% contextual e.g., Slovak ch h c

For instance, here is a comparison in the current default locale
(Australian-English):

\begin{Schunk}
\begin{Sinput}
R> "chaotic" %s<% "hard"  # c < h
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}

Similar comparison in Polish:

\begin{Schunk}
\begin{Sinput}
R> stri_cmp_lt("chłodny", "hardy", locale="pl_PL")  # c < h
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}

And now for something completely different -- the Slovak language:

\begin{Schunk}
\begin{Sinput}
R> stri_cmp_lt("chladný", "hladný", locale="sk_SK") # ch > h
\end{Sinput}
\begin{Soutput}
[1] FALSE
\end{Soutput}
\end{Schunk}

% stri_cmp("chladný", "hladný", locale="sk_SK")    # -1,0,1 encode <,=,>


This is an example of the locale-aware comparison that is context-sensitive
and which goes beyond the simple code-pointwise comparison.
In the example above, a \textit{contraction} occurred:
in Slovak,
two code points ``\code{ch}'' are treated as a single entity
and are sorted after ``\code{h}'':


Compare the ordering of Polish and Slovak words:

\begin{Schunk}
\begin{Sinput}
R> stri_sort(c("chłodny", "hardy", "cichy", "cenny"), locale="pl_PL")
\end{Sinput}
\begin{Soutput}
[1] "cenny"   "chłodny" "cichy"   "hardy"
\end{Soutput}
\begin{Sinput}
R> stri_sort(c("cudný", "chladný", "hladný", "čudný"), locale="sk_SK")
\end{Sinput}
\begin{Soutput}
[1] "cudný"   "čudný"   "hladný"  "chladný"
\end{Soutput}
\end{Schunk}

% stri_sort(c("cudný", "chladný", "hladný"), locale="cs_CZ")


An opposite situation is called an \textit{expansion}:

\begin{Schunk}
\begin{Sinput}
R> german_k_words <- c("können", "kondensieren", "kochen", "korrelieren")
R> stri_sort(german_k_words, locale="de_DE")
\end{Sinput}
\begin{Soutput}
[1] "kochen"       "kondensieren" "können"       "korrelieren"
\end{Soutput}
\begin{Sinput}
R> stri_sort(german_k_words, locale="de_DE@collation=phonebook")
\end{Sinput}
\begin{Soutput}
[1] "kochen"       "können"       "kondensieren" "korrelieren"
\end{Soutput}
\end{Schunk}

% TODO:  something in-between??

In the latter example, where we used the German phone-book order,
\code{"ö"} is treated as \code{"oe"}.


% stri_rank example with numeric=TRUE below




\subsection{Collator options}\label{Sec:collator_opts}

Table~\ref{Tab:collator_opts} lists the options
that can be passed to \code{stri_opts_collator()} via the dot-dot-dot
parameter, ``\code{...}'', in
all the functions that rely on the \pkg{ICU} Collator.
Below we would like to attract the kind reader's attention
to some of them.

% https://unicode-org.github.io/icu/userguide/collation/ - many nice examples



\begin{table}[bt!]
\centering

\begin{tabularx}{1.0\linewidth}{lX}
\toprule
\bfseries{Option}            &\bfseries Purpose \\
\midrule
\code{locale}             & a string specifying the locale to use; \code{NULL}
(default) or \code{""} for the current default locale as indicated by
\code{stri\_locale\_get()} \\
\midrule
\code{strength}           & an integer in $\{1,2,3,4\}$ defining collation strength;
1 for the most permissive collation rules, 4 for the strictest ones;
defaults to 3 \\
\midrule
\code{uppercase\_first}    & logical; \code{NA} (default) orders upper
and lower
case letters in accordance to their tertiary weights, \code{TRUE} forces upper
case letters to sort before lower case letters, \code{FALSE} does the opposite \\
\midrule
\code{numeric}            & logical; if \code{TRUE}, a collation key
for the numeric value of substrings of digits is generated; this is a way to
make \code{"100"} ordered
after \code{"2"}; defaults to \code{FALSE} \\
\midrule
\code{case\_level}         & logical; if \code{TRUE}, an extra case level
(positioned before the third level) is generated; defaults to \code{FALSE} \\
\midrule
\code{normalisation}      & logical; if \code{TRUE}, then an incremental
check is performed to see whether input data are in the FCD (``fast C or D'') form;
if data are not in the FCD form, the incremental NFD normalisation is performed,
see Section~\ref{Sec:normalisation}; defaults to \code{FALSE}   \\
\midrule
\code{alternate\_shifted}  & logical; if \code{FALSE} (default),
all code points with non-ignorable primary weights are handled in the same way;
\code{TRUE} causes the code points
with primary weights that are less than or equal to the variable top value
to be ignored on the primary level and moved to the quaternary level; this can be
used to, e.g., ignore punctuation, see the examples provided \\ \midrule
\code{french}             & logical; \code{TRUE} results in secondary
weights being considered backwards, i.e., ordering according to the last accent difference
-- nowadays only used in Canadian-French; defaults to \code{FALSE} \\
\bottomrule
\end{tabularx}

\caption{\label{Tab:collator_opts} Options for the \pkg{ICU}
Collator that can be passed to \code{stri\_opts\_collator()}.}
\end{table}




\paragraph{Collation strength.}
The Unicode Collation Algorithm \citep{uts10:collation}
can go beyond simple canonical equivalence:
it can treat some other (depending on the context)
differences as \textit{negligible} too.

The \code{strength} option controls the Collator's ``attention to detail''.
For instance, it can be used to make the ligature ``ff'' (U+FB00)
compare equal to the two-letter sequence ``f{}f'':

\begin{Schunk}
\begin{Sinput}
R> stri_cmp_equiv("\ufb00", "ff", strength=2)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}

\noindent
which is not the case at the default strength level (3).

% stri_cmp_equiv("\ufb00", "ff")

% \clearpage


Generally, four (nested) levels of inter-string differences can be distinguished:
% https://unicode-org.github.io/icu/userguide/collation/concepts.html
\begin{enumerate}
\item A primary difference -- the strongest one -- occurs where
there is a mismatch between base characters (e.g., \code{"a"} vs~\code{"b"}).

\item Some character accents can be considered a secondary difference
in many languages. However, in other ones, an accented letter is considered
a unique letter.

\item Distinguishing between upper- and lower case typically happens
on the tertiary level (see, however, the \texttt{case\_level} option).


\item If \code{alternate\_shifted} is \code{TRUE},
differences in punctuation
can be determined at the quaternary level. This is also meaningful
in the processing of Hiragana text.


\end{enumerate}

\vbox{
\paragraph{Ignoring case.}
Note which strings are deemed equivalent when
considering different collation strengths:

\begin{Schunk}
\begin{Sinput}
R> x <- c("gro\u00df", "gross", "GROSS", "Gro\u00df", "Gross")
R> stri_unique(x, strength=1)                  # ß == ss, case insensitive
\end{Sinput}
\begin{Soutput}
[1] "groß"
\end{Soutput}
\begin{Sinput}
R> stri_unique(x, strength=2)                  # ß != ss, case insensitive
\end{Sinput}
\begin{Soutput}
[1] "groß"  "gross"
\end{Soutput}
\end{Schunk}
}


Hence, strength equal to 1 takes only primary differences
into account. Strength of 2 will also be sensitive to secondary differences
(distinguishes between ``ß'' and ``ss'' above), but will ignore
tertiary differences (case).

Also, introducing an extra case level yields
a case sensitive comparison that ignores secondary differences:

\begin{Schunk}
\begin{Sinput}
R> stri_unique(x, strength=1, case_level=TRUE) # ß == ss, case sensitive
\end{Sinput}
\begin{Soutput}
[1] "groß"  "GROSS" "Groß"
\end{Soutput}
\end{Schunk}


\paragraph{Ignoring some punctuation.}
Here are some effects of changing the  \code{alternate\_shifted} option,
which allows for ignoring some punctuation marks:

\begin{Schunk}
\begin{Sinput}
R> x <- c("code point", "code-point", "codepoint", "CODE POINT", "CodePoint")
R> stri_unique(x, alternate_shifted=TRUE)  # strength=3
\end{Sinput}
\begin{Soutput}
[1] "code point" "CODE POINT" "CodePoint"
\end{Soutput}
\begin{Sinput}
R> stri_unique(x, alternate_shifted=TRUE, strength=2)
\end{Sinput}
\begin{Soutput}
[1] "code point"
\end{Soutput}
\end{Schunk}

In the latter case, all strings are considered equivalent.
Ignoring case but not punctuation yields:

\begin{Schunk}
\begin{Sinput}
R> stri_unique(x, strength=2)
\end{Sinput}
\begin{Soutput}
[1] "code point" "code-point" "codepoint"
\end{Soutput}
\end{Schunk}

%
% % outer(x, x, stri_cmp, strength=2)
%
% primary secondary tertiary quaternary  equal
%
%  	A and B are equivalent (equal at all levels)
%
%  	canonically equivalent: the sequences represent essentially the same text, but with different actual sequences (see Unicode Normalisation Forms
%  	in  Section~\ref{Sec:normalisation} and \citealp{usa15:normalization})
%
% quote: The default for strength in UCA is tertiary; ???
%
% quote:. For example, setting the strength to exclude differences at Level 3 has the effect of ignoring case and compatibility format distinctions between letters when matching. Excluding differences at Level 2 has the effect of also ignoring accentual distinctions when matching.
%
%




\paragraph{Backward secondary sorting.}
The French Canadian Sorting Standard CAN/CSA Z243.4.1 (historically this had been
the default for all French locales) requires the word ordering with respect
to  the last accent difference. Such a behaviour can be applied
either by setting the French-Canadian locale or by passing the \code{french=TRUE}
option to the Collator.

\begin{Schunk}
\begin{Sinput}
R> stri_sort(c("cote", "côte", "coté", "côté"), locale="fr_FR")
\end{Sinput}
\begin{Soutput}
[1] "cote" "coté" "côte" "côté"
\end{Soutput}
\begin{Sinput}
R> stri_sort(c("cote", "côte", "coté", "côté"), locale="fr_CA") # french=TRUE
\end{Sinput}
\begin{Soutput}
[1] "cote" "côte" "coté" "côté"
\end{Soutput}
\end{Schunk}



\paragraph{Sorting numerals.}
By default, just like in base \proglang{R} and most other programming
languages, a lexicographic ordering is used: the corresponding
code points are being compared one by one, from left to right,
and once a difference
is detected, the result is returned immediately.

\begin{Schunk}
\begin{Sinput}
R> x <- c("a1", "a2", "a11", "a1", "a99", "a10", "a100", "a2", "a9", "a2")
R> stri_sort(x)
\end{Sinput}
\begin{Soutput}
 [1] "a1"   "a1"   "a10"  "a100" "a11"  "a2"   "a2"   "a2"   "a9"   "a99"
\end{Soutput}
\end{Schunk}

For example, \code{"a99"} is ordered after \code{"a100"},
because \code{"a" == "a"} (first characters are equal)
but then \code{"9" > "1"} (second characters are already different).

Let us, however, note the effect of setting the \code{numeric} option
on the sorting of strings that involves numbers:

\begin{Schunk}
\begin{Sinput}
R> stri_sort(x, numeric=TRUE)
\end{Sinput}
\begin{Soutput}
 [1] "a1"   "a1"   "a2"   "a2"   "a2"   "a9"   "a10"  "a11"  "a99"  "a100"
\end{Soutput}
\end{Schunk}


% <<echo=-1>>=
% set.seed(123)
% slowa <- sample(readLines(
%    "https://raw.githubusercontent.com/" %s+% # złączenie napisów, zob. dalej
%    "gagolews/Programowanie_w_jezyku_R/master/wyd2/dane/PL_ispell.txt"
% )) # baza słów w języku polskim
% length(slowa)
% cat(sample(slowa, 5), sep=", ")
% print(microbenchmark::microbenchmark(
%    sort      = sort(slowa),
%    stri_sort = stri_sort(slowa),
%    times=10
% ), signif=3)
% @


Here is an example of sorting a data frame
with respect to two criteria:

\begin{Schunk}
\begin{Sinput}
R> X <- data.frame(a=x, b=runif(length(x)))
R> X[order(-stri_rank(X$a, numeric=TRUE), X$b), ]
\end{Sinput}
\begin{Soutput}
      a        b
7  a100 0.528105
5   a99 0.940467
3   a11 0.408977
6   a10 0.045556
9    a9 0.551435
10   a2 0.456615
2    a2 0.788305
8    a2 0.892419
1    a1 0.287578
4    a1 0.883017
\end{Soutput}
\end{Schunk}

The object is now ordered by the first column decreasingly
(using a ``numeric'' order) and ties are resolved based on increasing
values in the second column.


\paragraph{A note on compatibility equivalence.}
In Section~\ref{Sec:normalisation} we describe different ways to normalise
canonically equivalent code point sequences so that they are
represented by the same code points, which can account for some negligible
differences (as in the ``a with ogonek'' example above).

Apart from ignoring punctuation and case, the Unicode Standard Annex \#15 \citep{usa15:normalization}
also discusses the so-called \textit{compatibility} equivalence of strings.
This is a looser form of similarity; it is observed where
there is the same \textit{abstract} content, yet displayed
by means of different glyphs, for instance ``¼'' (U+00BC) vs~``\code{1/4}''
or ``$\mathbb{R}$'' vs~``\proglang{R}''.
In the latter case, whether these should be treated as equal,
depends on the context (e.g., this can be the set of real numbers
vs~one's favourite programming language).
Compatibility decompositions (NFKC, NFKD)
mentioned in Section~\ref{Sec:normalisation}
or other types of transliteration can be used to normalise strings so that
such differences are not accounted for.

Also, for ``fuzzy'' matching of strings,
the \pkg{stringdist} package \citep{stringdist} might be helpful.


% adist, agrep, \pkg{stringdist} + citation package -- "fuzzy pattern matching"
% some approximate NNs?
% \pkg{stringdist} -- out of scope of stringi




%stri_cmp_equiv("\u00bc", "1/4", strength=0, alternate_shifted=TRUE)


% > stri_trans_general("a\u0328ą", "name")
% [1] "\\N{LATIN SMALL LETTER A}\\N{COMBINING OGONEK}\\N{LATIN SMALL LETTER A WITH OGONEK}"





\subsection{Searching for fixed strings revisited}

The \pkg{ICU} Collator can also be utilised
where there is a need to locate the occurrences of simple textual patterns.
The counterparts of the string search functions
described in Section~\ref{Sec:fixed}
have their names ending with \code{*_coll()}.
They are slower than them, but are more appropriate in NLP activities.

For instance:

\begin{Schunk}
\begin{Sinput}
R> stri_detect_coll("Er ist so groß.", "GROSS", strength=1, locale="de_AT")
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
R> stri_detect_coll("On je chladný", "chladny", strength=1, locale="sk_SK")
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}
% \end{ciekawostka}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Other operations}\label{Sec:other}

In the sequel, we cover the functions that deal with
text boundary detection, random string generation,
date/time formatting and parsing, amongst others.


% \color{blue}
\subsection{Analysing text boundaries}\label{Sec:BoundaryAnalysis}

Text boundary analysis aims at locating linguistic delimiters
for the purpose of splitting text into lines,
word-wrapping, counting characters or
words, locating particular text units (e.g.,
the 3rd sentence), etc.

Generally, text boundary analysis is a locale-sensitive operation,
see \citep{usa29:segmentation}.
For example, in Japanese and Chinese, spaces are not used for
separation of words  --
a line break can occur even in the middle of a word. Nevertheless,
these languages have punctuation and diacritical marks that cannot
start or end a line, so this must also be taken into account.

The \pkg{ICU} Break Iterator\footnote{See the \pkg{ICU} User Guide
on {Boundary Analysis}, \url{https://unicode-org.github.io/icu/userguide/boundaryanalysis/}.}
comes in four flavours (see the \code{type} option
in \code{stri_opts_brkiter()}):
\code{character}, \code{work}, \code{line_break}, and \code{sentence}.

We have access to functions such as
\code{stri_count_boundaries()},
\code{stri_split_boundaries()},
\code{stri_extract_*_boundaries()}, and
\code{stri_locate_*_boundaries()},
as well as their specialised
versions:
\code{stri_count_words()},
\code{stri_extract_*_words()}, and
\code{stri_split_lines()}, amongst others.
For example:


\begin{Schunk}
\begin{Sinput}
R> x <- "The\u00a0above-mentioned    features are useful. " %s+%
+    "My hovercraft is full of eels, eggs, and spam."
\end{Sinput}
\end{Schunk}

Number of sentences:

\begin{Schunk}
\begin{Sinput}
R> stri_count_boundaries(x, type="sentence")
\end{Sinput}
\begin{Soutput}
[1] 2
\end{Soutput}
\end{Schunk}

The list of all the words:

\begin{Schunk}
\begin{Sinput}
R> stri_extract_all_words(x)
\end{Sinput}
\begin{Soutput}
[[1]]
 [1] "The"        "above"      "mentioned"  "features"   "are"
 [6] "useful"     "My"         "hovercraft" "is"         "full"
[11] "of"         "eels"       "eggs"       "and"        "spam"
\end{Soutput}
\end{Schunk}


% \code{?stri_opts_brkiter}



\subsection{Trimming, padding, and other formatting}

The following functions can be used for pretty-printing
character strings or text on the console,
dynamically generating reports (e.g.,
with \code{Sweave()} or \pkg{knitr}; see \citealp{knitr}),
or creating text files
(e.g., with \code{stri\_write\_lines()}; see Section~\ref{Sec:read_lines}).



\paragraph{Padding.}
\code{stri\_pad()} pads strings with some character so that they
reach the desired widths (as in \code{stri_width()}).
This can be used to centre, left-, or right-align a message
when printed with, e.g.,  \code{cat()}.


\begin{Schunk}
\begin{Sinput}
R> cat(stri_pad("SPAMITY SPAM", width=77, side="both", pad="."))
\end{Sinput}
\begin{Soutput}
................................SPAMITY SPAM.................................
\end{Soutput}
\end{Schunk}

% cat(stri_pad("spam", width=77, side="left"))

% <<>>=
% x <- "*" %s*% 1:3
% y <- "*" %s*% 3:1
% w <- max(stri_length(c(x, y)))
% cat(stri_join(stri_pad(x, width=w, side="left"),
%                stri_pad(y, width=w, side="left"),
%                collapse="\n", sep=" | "))
% @





\paragraph{Trimming.}
A dual operation is that of trimming from the left or right side
of strings:

\begin{Schunk}
\begin{Sinput}
R> x <- "      spam, eggs, and lovely spam.\n"
R> stri_trim(x)  # side="both"
\end{Sinput}
\begin{Soutput}
[1] "spam, eggs, and lovely spam."
\end{Soutput}
\end{Schunk}

% stri_trim(x, pattern="[^\\n\\p{Z}\\p{P}\\p{S}]")


\paragraph{Word wrapping.}
The \code{stri\_wrap()} function splits each (possibly long)
string in a character vector into chunks of at most a given width.
By default, the dynamic word wrap algorithm \citep{Knuth:wrap}
that minimises the raggedness of the formatted text is used.
However, there is also an option (\code{cost\_exponent=0})
to use the greedy alignment,
for compatibility with the built-in \code{strwrap()}.

\begin{Schunk}
\begin{Sinput}
R> x <- stri_rand_lipsum(1)  # random text paragraph
R> cat(stri_wrap(x, width=74, indent=8, exdent=4, prefix="> "), sep="\n")
\end{Sinput}
\begin{Soutput}
>         Lorem ipsum dolor sit amet, quis donec pretium auctor, quis id.
>     Mauris rhoncus donec amet egestas sagittis ipsum per. Sed, sociis
>     amet. Aliquam fusce dictumst sed vehicula ultrices arcu. Eros,
>     netus et. Amet amet mi vestibulum vitae dapibus ut felis. Magnis
>     in vestibulum egestas massa curabitur a ut, eget in in facilisis.
>     Etiam odio fermentum sit ante ridiculus sit elit. Sapien torquent
>     fermentum tortor gravida ornare sapien consequat et sem turpis. Hac
>     vel lacus habitasse et id non. Metus habitasse sed lacinia nibh ex
>     metus. Amet nam vestibulum ornare tincidunt massa sed ullamcorper.
\end{Soutput}
\end{Schunk}

% Note that, by default, the splitting is performed at line breaks
% (compare Section~\ref{Sec:BoundaryAnalysis}).






\paragraph{Applying string templates.}
\code{stri_sprintf()} is a Unicode-aware rewrite of the built-in
\code{sprintf()} function. In particular, it enables formatting and
padding based on character width, not just the number of code points.
The function is also available as a binary operator \code{\%s\$\%},
which is similar to Python's \code{\%} overloaded for
objects of type \code{str}.

\begin{Schunk}
\begin{Sinput}
R> cat(stri_sprintf("[%6s]", c("abcd", "\u200b\u200b\u200bąß²€")), sep="\n")
\end{Sinput}
\begin{Soutput}
[  abcd]
[  ​​​ąß²€]
\end{Soutput}
\end{Schunk}

The above guarantees that the two output strings are
of at least width of 6 (plus the square brackets).


\ifnotJSSversion
\begin{Schunk}
\begin{Sinput}
R> "value='%.4f'" %s$% pi  # equivalently: "value='%.4f'" %s$% list(pi)
\end{Sinput}
\begin{Soutput}
[1] "value='3.1416'"
\end{Soutput}
\begin{Sinput}
R> "%s='%.*3$f'" %s$% list("pi", pi, 1:4)
\end{Sinput}
\begin{Soutput}
[1] "pi='3.1'"    "pi='3.14'"   "pi='3.142'"  "pi='3.1416'"
\end{Soutput}
\end{Schunk}
\fi

\subsection{Generating random strings}

Apart from \code{stri\_rand\_lipsum()},
which produces random-ish text paragraphs (``placeholders'' for real text),
we have access to a function that generates sequences of characters
uniformly sampled (with replacement) from a given set.

For example, here are 5 random ACTG strings of lengths from 2 to 6:

\begin{Schunk}
\begin{Sinput}
R> stri_rand_strings(5, 2:6, "[ACTG]")
\end{Sinput}
\begin{Soutput}
[1] "CT"     "CTT"    "AGTG"   "CTCGG"  "ATAACT"
\end{Soutput}
\end{Schunk}

\ifnotJSSversion
Moreover:

\begin{Schunk}
\begin{Sinput}
R> stri_rand_strings(1, 8, "[\\p{script=Katakana}&\\p{L}]")
\end{Sinput}
\begin{Soutput}
[1] "ﾐｮㇿ𛅧ｧｱヾㇷ"
\end{Soutput}
\end{Schunk}
\fi

See Section~\ref{Sec:RegexIndividualChars}
and \code{help("stringi-search-charclass")}
for different ways to specify character sets.





% \color{blue}
\subsection{Transliterating}

Transliteration, in its broad sense, deals with the substitution
of characters or their groups for different ones, according to some
well-defined, possibly context-aware, rules.
It may be useful, amongst others, when "normalising"
pieces of strings or identifiers so that they can be more easily
compared with each other.


\paragraph{Case mapping.}
% https://www.unicode.org/versions/Unicode11.0.0/
Mapping to  upper, lower, or title case
is a language- and context-sensitive operation
that can change the total number of code points in a string.

% (character mapping may depend on its surrounding characters). https://unicode-org.github.io/icu/userguide/transforms/casemappings.html


\begin{Schunk}
\begin{Sinput}
R> stri_trans_toupper("groß")
\end{Sinput}
\begin{Soutput}
[1] "GROSS"
\end{Soutput}
\begin{Sinput}
R> stri_trans_tolower("Iİ", locale = "tr_TR")               # Turkish
\end{Sinput}
\begin{Soutput}
[1] "ıi"
\end{Soutput}
\begin{Sinput}
R> stri_trans_totitle("ijsvrij yoghurt", locale = "nl_NL")  # Dutch
\end{Sinput}
\begin{Soutput}
[1] "IJsvrij Yoghurt"
\end{Soutput}
\end{Schunk}




% Also: case folding - not locale-sensitive for the purpose of comparing strings



\paragraph{Mapping between specific characters.}
When a fast 1-to-1 code point translation is required, we can call:

\begin{Schunk}
\begin{Sinput}
R> stri_trans_char("GATAAATCTGGTCTTATTTCC", "ACGT", "tgca")
\end{Sinput}
\begin{Soutput}
[1] "ctatttagaccagaataaagg"
\end{Soutput}
\end{Schunk}

Here, ``\code{A}'', ``\code{C}'', ``\code{G}'', and ``\code{T}''
is replaced with
``\code{t}'', ``\code{g}'', ``\code{c}'', and ``\code{a}'', respectively.



\paragraph{General transforms.}
\code{stri_trans_general()} provides access to a wide range of text transforms
defined by \pkg{ICU}, whose catalogue can be accessed by calling
\code{stri_trans_list()}.

\begin{Schunk}
\begin{Sinput}
R> sample(stri_trans_list(), 9)  # a few random entries
\end{Sinput}
\begin{Soutput}
[1] "Any-und_FONIPA" "Any-FCD"        "Deva-Guru"      "yo-yo_BJ"
[5] "Taml-Orya"      "Tamil-Arabic"   "hy-ar"          "de-ASCII"
[9] "Any-Kana"
\end{Soutput}
\end{Schunk}

For example, below we apply a transliteration chain:
first, we convert to upper case, and then we convert characters
in the Latin script to ASCII.


\begin{Schunk}
\begin{Sinput}
R> stri_trans_general("groß© żółć La Niña köszönöm", "upper; latin-ascii")
\end{Sinput}
\begin{Soutput}
[1] "GROSS(C) ZOLC LA NINA KOSZONOM"
\end{Soutput}
\end{Schunk}

% stri_trans_general("I'll come -- that's what she said.", "any-publishing")

Custom rule-based transliteration is also
supported\footnote{See the \pkg{ICU} User Guide on {General Transforms}
for more details,
\url{https://unicode-org.github.io/icu/userguide/transforms/general/}.
}. It can be used, for instance, to generate different romanisations
of non-Latin alphabets.

%Deviate from the ICU rules of romanisation of Korean,
% https://en.wikipedia.org/wiki/Romanization_of_Korean
%see https://en.wikipedia.org/wiki/Revised_Romanization_of_Korean

% <<>>=
% x <- "\uC885\uB85C\uAD6C \uC0AC\uC9C1\uB3D9"
% stringi::stri_trans_general(x, "Hangul-Latin")
% id <- "
%     :: NFD;
%     \u11A8 > k;
%     \u11AE > t;
%     \u11B8 > p;
%     \u1105 > r;
%     :: Hangul-Latin;
% "
% stringi::stri_trans_general(x, id, rules=TRUE)
% @

% stri_trans_general("stringi", "latin-greek")
% stri_trans_general("Пётр Ильич Чайковский",
%     "cyrillic-latin; nfd; [:nonspacing mark:] remove; nfc")

% not locale-dependent



% It's getting hotter with these:
%
% ```{r}
% stri_trans_general("w szczebrzeszynie chrząszcz brzmi w trzcinie", "pl-pl_fonipa")
% # and now the same in the XSampa ASCII-range representation:
% stri_trans_general("w szczebrzeszynie chrząszcz brzmi w trzcinie", "pl-pl_fonipa; ipa-xsampa")
% ```

%  stri_trans_general("zażółć gęślą jaźń", "[\\p{Z}] remove")

%  stri_trans_general("Let's go... -- that's what she said.", "any-publishing")






\subsection{Parsing and formatting date and time}\label{Sec:datetime}

In base \proglang{R}, dealing with temporal data in regional
settings other than the current locale is somewhat difficult.
For instance, many will find the task of parsing the following Polish date problematic:

\begin{Schunk}
\begin{Sinput}
R> x <- "1 maja 2021 r., godz. 17:17:32"
\end{Sinput}
\end{Schunk}

\pkg{stringi} connects to the \pkg{ICU} date and time
services so that this becomes an easy exercise:


\begin{Schunk}
\begin{Sinput}
R> stri_datetime_parse(x, "dd MMMM yyyy 'r., godz.' HH:mm:ss",
+    locale="pl_PL", tz="Europe/Warsaw")
\end{Sinput}
\begin{Soutput}
[1] "2021-05-01 17:17:32 CEST"
\end{Soutput}
\end{Schunk}

This function returns an object of class \code{POSIXct},
for compatibility with base \proglang{R}.
Note, however, that
\pkg{ICU} uses its own format patterns\footnote{
See the \pkg{ICU} User Guide on {Formatting Dates and Times},
\url{https://unicode-org.github.io/icu/userguide/format_parse/datetime/}.
}. For convenience,
\code{strftime()}- and \code{strptime()}-like
templates can be converted with \code{stri_datetime_fstr()}:

\begin{Schunk}
\begin{Sinput}
R> stri_datetime_parse(x,
+    stri_datetime_fstr("%d %B %Y r., godz. %H:%M:%S"),
+    locale="pl_PL", tz="Europe/Warsaw")
\end{Sinput}
\begin{Soutput}
[1] "2021-05-01 17:17:32 CEST"
\end{Soutput}
\end{Schunk}

\ifnotJSSversion
Relative dates are also supported:

\begin{Schunk}
\begin{Sinput}
R> stri_datetime_format(
+    stri_datetime_add(stri_datetime_now(), 1, "day"), # add 1 day to 'now'
+    "datetime_relative_long",              # full format, relative to 'now'
+    locale="en_NZ", tz="NZ")
\end{Sinput}
\begin{Soutput}
[1] "tomorrow at 6:55:17 pm NZST"
\end{Soutput}
\end{Schunk}
\fi

For example, here is how we can access different calendars:

\begin{Schunk}
\begin{Sinput}
R> stri_datetime_format(
+    stri_datetime_create(2020, 1:12, 1),
+    "date_long",
+    locale="@calendar=hebrew")
\end{Sinput}
\begin{Soutput}
 [1] "4 Tevet 5780"    "6 Shevat 5780"   "5 Adar 5780"     "7 Nisan 5780"
 [5] "7 Iyar 5780"     "9 Sivan 5780"    "9 Tamuz 5780"    "11 Av 5780"
 [9] "12 Elul 5780"    "13 Tishri 5781"  "14 Heshvan 5781" "15 Kislev 5781"
\end{Soutput}
\begin{Sinput}
R> stri_datetime_format(
+    stri_datetime_create(2020, c(2, 8), c(4, 7)),
+    "date_full",
+    locale="ja_JP@calendar=japanese")
\end{Sinput}
\begin{Soutput}
[1] "令和2年2月4日火曜日" "令和2年8月7日金曜日"
\end{Soutput}
\end{Schunk}

\noindent
Above we have selected the Hebrew calendar within the
English locale and the Japanese calendar in the Japanese locale.


% \code{he_IL@calendar=hebrew}
% \code{ja_JP_TRADITIONAL}

% stri_locale_info("@calendar=hebrew")

% \code{@calendar=hebrew}



% timezone



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Input and output}\label{Sec:io}

This section deals with some more advanced topics related to the
operability of text processing applications
between different platforms. In particular, we discuss
how to assure that data read from various input connections
are interpreted in the correct manner.



\subsection{Dealing with Unicode code points}\label{Sec:codepoints}

The Unicode Standard (as well as the
Universal Coded Character Set, i.e., ISO/IEC 10646)
currently defines over 140{,}000 abstract characters together with
their corresponding \textit{code points} -- integers
between 0 and 1{,}114{,}111 (or 0000${}_{16}$ and 10FFFF${}_{16}$
in hexadecimal notation, see \url{https://www.unicode.org/charts/}).
In particular, here is the number of the code points in
some popular categories (compare Section~\ref{Sec:RegexIndividualChars}),
such as letters, numbers, and the like.

\begin{Schunk}
\begin{Sinput}
R> z <- c("\\p{L}", "\\p{Ll}", "\\p{Lu}", "\\p{N}", "\\p{P}", "\\p{S}",
+    "\\w", "\\d", "\\s")
R> structure(stri_count_regex(stri_enc_fromutf32(
+    setdiff(1:0x10ffff, c(0xd800:0xf8ff))), z), names=z)
\end{Sinput}
\begin{Soutput}
 \\p{L} \\p{Ll} \\p{Lu}  \\p{N}  \\p{P}  \\p{S}     \\w     \\d     \\s
 131241    2155    1791    1781     798    7564  134564     650      25
\end{Soutput}
\end{Schunk}

Yet, most of the code points are still unallocated.
The Unicode standard is occasionally updated, e.g., the
most recent versions were supplemented with over 1{,}000 emojis.


The first 255 code points are identical to the ones defined
by ISO/IEC 8859-1 (ISO Latin-1;
``Western European''), which itself extends US-ASCII (codes $\le 127=\text{7F}{}_{16}$).
For instance, the code point that we are used to denoting as U+007A
(the ``U+'' prefix is followed by a sequence of hexadecimal digits;
7A${}_{16}$ corresponds to decimal 122) encodes the lower case letter ``z''.
To input such a code point in \proglang{R}, we write:

\begin{Schunk}
\begin{Sinput}
R> "\u007A"  # or "\U0000007A"
\end{Sinput}
\begin{Soutput}
[1] "z"
\end{Soutput}
\end{Schunk}


For communicating with \pkg{ICU} and other libraries,
we may need to escape a given string, for example, as follows
(recall that to input a backslash in \proglang{R},
we must escape it with another backslash).

\begin{Schunk}
\begin{Sinput}
R> x <- "zß你好"
R> stri_escape_unicode(x)
\end{Sinput}
\begin{Soutput}
[1] "z\\u00df\\u4f60\\u597d"
\end{Soutput}
\end{Schunk}


% stri_trans_general(x, "[^\\u0000-\\u007f] any-hex") # except ASCII
% stri_trans_general(x, "[^\\u0000-\\u007f] any-hex/xml")
% stri_unescape_unicode("\\u007A")

\bigskip
It is worth noting that despite the fact that some output devices
might be unable to display certain code points correctly
(due to, e.g., missing fonts), the correctness of their
processing with \pkg{stringi} is still guaranteed by \pkg{ICU}.
Here is an example of an incorrect \textit{presentation} of an emoji,
generated by a malconfigured \XeLaTeX{} engine:

\begin{Schunk}
\begin{Sinput}
R> "\U001F600" # the grinning face emoji, (:               - font unavailable
\end{Sinput}
\begin{Soutput}
[1] "😀"
\end{Soutput}
\end{Schunk}

Nevertheless, the programmatic handling of such a code point is unaffected:

\begin{Schunk}
\begin{Sinput}
R> stri_trans_general("\U001F600", "any-name") # query the character database
\end{Sinput}
\begin{Soutput}
[1] "\\N{GRINNING FACE}"
\end{Soutput}
\end{Schunk}



% ```{r}
% stri_trans_general("ą1©,", "any-name")
% stri_trans_general("\\N{LATIN SMALL LETTER SHARP S}", "name-any")
% ```
%
%




\subsection{Character encodings}\label{Sec:encoding}

When storing strings in RAM or on the disk,
we need to decide upon the actual way
of representing the code points as sequences of bytes.
The two most popular \textit{encodings} in the Unicode family are
UTF-8 and UTF-16:

\begin{Schunk}
\begin{Sinput}
R> x <- "abz0ąß你好!"
R> stri_encode(x, to="UTF-8", to_raw=TRUE)[[1]]
\end{Sinput}
\begin{Soutput}
 [1] 61 62 7a 30 c4 85 c3 9f e4 bd a0 e5 a5 bd 21
\end{Soutput}
\begin{Sinput}
R> stri_encode(x, to="UTF-16LE", to_raw=TRUE)[[1]]  # little-endian
\end{Sinput}
\begin{Soutput}
 [1] 61 00 62 00 7a 00 30 00 05 01 df 00 60 4f 7d 59 21 00
\end{Soutput}
\end{Schunk}

\proglang{R}'s current platform-default encoding, which we shall
refer to as the \textit{native} encoding, is defined via the
\code{LC_CTYPE} locale category in
\code{Sys.getlocale()}. This is the representation assumed,
e.g., when reading data from the standard input
or from files (e.g., when \code{scan()} is called).
% as well as written to the output devices
% (e.g., \code{print()} and \code{cat()}).
For instance, Central European versions of Windows will assume
the ``\code{windows-1250}'' code page.
MacOS as well as most Linux boxes work with UTF-8 by default\footnote{
It is expected that future R releases will support UTF-8 natively
thanks to the Universal C Runtime (UCRT) that is available for Windows 10.
% https://developer.r-project.org/Blog/public/2020/05/02/utf-8-support-on-windows/index.html
}

% Character vectors in \proglang{R} resemble lists of raw-type vectors
% (each ending with byte 0x00).
All strings in \proglang{R} have an associated encoding mark
which can be read by calling \code{Encoding()} or, more conveniently,
\code{stri\_enc\_mark()}.
Most importantly, strings in ASCII, ISO-8859-1 (``\code{latin1}''),
UTF-8, and the native encoding can coexist.
Whenever a non-Unicode string is passed to a function in \pkg{stringi},
it is silently converted to UTF-8 or UTF-16, depending on the requested
operation (some \pkg{ICU} services are only available for {UTF-16} data).
Over the years, this has proven a robust, efficient, and maximally portable
design choice -- Unicode can be thought of as a superset of every other encoding.
Moreover, in order to guarantee the correctness and high performance of
the string processing pipelines, \pkg{stringi} always\footnote{With a few
obvious exceptions, such as \code{stri\_encode()}.} outputs
UTF-8 data.


\subsection{Reading and writing text files and converting between encodings}\label{Sec:read_lines}

According to a report by W3Techs\footnote{See
\url{https://w3techs.com/technologies/cross/character_encoding/ranking}.},
as of 2021--05--05, 96.8\% of websites use UTF-8.
Nevertheless, other encodings can still be encountered.

\paragraph{Reading and writing text files.}
If we know the encoding of a text file  in advance,
\code{stri\_read\_lines()} can be used to read
the data in a manner similar to the built-in \code{readLines()} function
(but with a much easier access to encoding conversion):

For instance, below we read a text file encoded in ISO-8859-1:

\begin{Schunk}
\begin{Sinput}
R> x <- stri_read_lines("ES_latin1.txt", encoding="ISO-8859-1")
R> head(x, 4)  # x is in UTF-8 now
\end{Sinput}
\begin{Soutput}
[1] "CANTO DE CALÍOPE - Miguel de Cervantes"
[2] ""
[3] "Al dulce son de mi templada lira,"
[4] "prestad, pastores, el oído atento:"
\end{Soutput}
\end{Schunk}


We can call \code{stri_write_lines()} to write the contents
of a character vector to a file (each string will
constitute a separate text line), with any output encoding.




\paragraph{Detecting encoding.}
However, if a file's encoding is not known in advance, there are
a certain functions that can aid in encoding detection.
First, we can read the resource in form of a raw-type vector:

% Character vectors in \proglang{R} resemble lists of raw-type vectors
% (each ended up with byte 0x00). Each string has to be properly "decoded" so that textual information may be read from such a byte stream. This "decoding scheme" is simply called a character encoding.
%
% In other words, data in computer's memory are just bytes (small integer values) – an encoding is a way to represent characters with such numbers, it is a semantic "key" to understand a given byte sequence. For example, in ISO-8859-2 (Central European), the value 177 represents Polish ``a with ogonek'', and in ISO-8859-1 (Western European), the same value meas the ``plus-minus'' sign. Thus, a character encoding is a translation scheme.

\begin{Schunk}
\begin{Sinput}
R> x <- stri_read_raw("ES_latin1.txt")
R> head(x, 24)  # vector of type raw
\end{Sinput}
\begin{Soutput}
 [1] 43 41 4e 54 4f 20 44 45 20 43 41 4c cd 4f 50 45 20 2d 20 4d 69 67 75 65
\end{Soutput}
\end{Schunk}

Then, to guess the encoding, we can call, e.g.:

\begin{Schunk}
\begin{Sinput}
R> stri_enc_isascii(x)
\end{Sinput}
\begin{Soutput}
[1] FALSE
\end{Soutput}
\begin{Sinput}
R> stri_enc_isutf8(x)   # false positives are possible
\end{Sinput}
\begin{Soutput}
[1] FALSE
\end{Soutput}
\end{Schunk}

\noindent
Alternatively, we can use:

\begin{Schunk}
\begin{Sinput}
R> stri_enc_detect(x)  # based on heuristics
\end{Sinput}
\begin{Soutput}
[[1]]
    Encoding Language Confidence
1 ISO-8859-1       es       0.81
2 ISO-8859-2       ro       0.36
3 ISO-8859-9       tr       0.20
4   UTF-16BE                0.10
5   UTF-16LE                0.10
\end{Soutput}
\end{Schunk}

\noindent
Nevertheless, encoding detection is an operation that relies on heuristics,
therefore there is a  chance that the output might be imprecise or even
misleading.




\paragraph{Converting encodings.}
Knowing the desired source and destination encoding precisely,
\code{stri_encode()} can be called to perform the conversion.
Contrary to the built-in \code{iconv()}, which relies
on different underlying libraries, the current function is portable
across operating systems.


\begin{Schunk}
\begin{Sinput}
R> y <- stri_encode(x, from="ISO-8859-1", to="UTF-8")
\end{Sinput}
\end{Schunk}

\code{stri_enc_list()}  provides a list of
supported encodings and their aliases in many different forms.
Encoding specifiers are normalised automatically, e.g.,
\code{"utf8"} is a synonym for \code{"UTF-8"}.


Splitting the output  into text lines gives:

\begin{Schunk}
\begin{Sinput}
R> tail(stri_split_lines1(y), 4)  # spoiler alert!
\end{Sinput}
\begin{Soutput}
[1] "A Homero iguala si a escrebir intenta,"
[2] "y a tanto llega de su pluma el vuelo,"
[3] "cuanto es verdad que a todos es notorio"
[4] "el alto ingenio de don DIEGO OSORIO."
\end{Soutput}
\end{Schunk}



% <<>>=
% stri_enc_info("utf8")
% @






% https://unicode-org.github.io/icu/userguide/strings/unicodeset.html
% https://unicode-org.github.io/icu/userguide/strings/properties.html



% \code{stri_encode()} \code{to_raw=TRUE}
%
% \code{stri_enc_get()}
%
% \code{stri_enc_toascii()}
%
% \code{stri_enc_tonative()}
%
% \code{stri_enc_toutf32()}
%
% \code{stri_enc_toutf8()}
%
% \code{stri_enc_fromutf32()}
%
%
% <<>>=
% stri_enc_info("cp1250")
% @
%
%
%
%
% \code{stri_encode()}
% \code{stri_trans_nf*()}








\subsection{Normalising strings}\label{Sec:normalisation}

In Section~\ref{Sec:Equivalence} we have provided some examples
of canonically equivalent strings whose code point representation was different.
Unicode normalisation forms C (Canonical composition, NFC) and D
(Canonical decomposition, NFD) can be applied so that they
will compare equal using bytewise matching \citep{usa15:normalization}.

\begin{Schunk}
\begin{Sinput}
R> x <- "a\u0328 ą"   # a, combining ogonek, space, a with ogonek
R> stri_enc_toutf32(  # code points as decimals
+    c(x, stri_trans_nfc(x), stri_trans_nfd(x)))
\end{Sinput}
\begin{Soutput}
[[1]]
[1]  97 808  32 261

[[2]]
[1] 261  32 261

[[3]]
[1]  97 808  32  97 808
\end{Soutput}
\end{Schunk}

Above we see some example code points before, after NFC,
and after NFD normalisation, respectively.

It might be a good idea to always normalise all the strings
read from external sources (files, URLs) with NFC.

Compatibility composition and decomposition normalisation forms (NFKC and
NFKD, respectively) are also available if
the removal of the formatting distinctions (font variants,
subscripts, superscripts, etc.) is desired. For example:


\begin{Schunk}
\begin{Sinput}
R> stri_trans_nfkd("r²︷")
\end{Sinput}
\begin{Soutput}
[1] "r2{"
\end{Soutput}
\end{Schunk}

Such text might be much easier to process or analyse statistically.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% -- Summary/conclusions/discussion -------------------------------------------

\section{Closing remarks}\label{Sec:conclusions}



% Other:
%
% \code{stri_stats_general()}
% \code{stri_stats_latex()}

We have reviewed the key design principles and facilities available in
\pkg{stringi}, including numerous operations
that  help implement and optimise data processing pipelines.
Let us again stress that many package features are provided by \pkg{ICU}, which
is a platform-independent project. Hence, information
presented above might be of interest to statisticians and data scientists
employing different programming environments as well.



Users seeking Unicode-aware replacements for base \proglang{R}
string processing functions are kindly referred to the \pkg{stringx}
package \citep{stringx}, which is a set of wrappers around \pkg{stringi}
offering a more classic API
(functions such as \code{grepl()}, \code{substring()}, etc.,
compare Table~\ref{Tab:oldstringr}).


\pkg{stringi} functions can also be accessed from within \proglang{C++}
code. Authors of statistical/data analysis software who would like to
speed up their projects are encouraged to check out
the \pkg{ExampleRcppStringi} package available at
\url{https://github.com/gagolews/ExampleRcppStringi},
which serves as a working prototype developed using \pkg{Rcpp} \citep{rcppbook}.








% TODO: check CITATION
%
% https://cran.r-project.org/web/packages/qdapRegex/index.html
% https://cran.r-project.org/web/packages/namedCapture/index.html
% https://cran.r-project.org/web/packages/rebus/index.html
% https://cran.r-project.org/web/packages/rematch2/index.html
% https://cran.r-project.org/web/packages/rex/index.html
% https://cran.r-project.org/web/packages/RVerbalExpressions/index.html
% https://cran.r-project.org/web/packages/inverseRegex/index.html
%
% other R packages TODO check CITATION
% https://cran.r-project.org/web/packages/rprintf/index.html
% https://cran.r-project.org/web/packages/ScrabbleScore/index.html
% https://cran.r-project.org/web/packages/snakecase/index.html
% https://cran.r-project.org/web/packages/strex/index.html
% https://cran.r-project.org/web/packages/stringb/index.html
% https://cran.r-project.org/web/packages/stringdist/index.html
% https://cran.r-project.org/web/packages/stringfish/index.html
% https://cran.r-project.org/web/packages/stringformattr/index.html
% https://cran.r-project.org/web/packages/textutils/index.html
% https://cran.r-project.org/web/packages/tidyselect/index.html
% https://cran.r-project.org/web/packages/tidystringdist/index.html
% https://cran.r-project.org/web/packages/unglue/index.html
% https://cran.r-project.org/web/packages/uniqtag/index.html
% https://cran.r-project.org/web/packages/yasp/index.html
% https://cran.r-project.org/web/packages/clustringr/index.html # genie supports clustering as well
% https://cran.r-project.org/web/packages/concatenate/index.html
% https://cran.r-project.org/web/packages/cwhmisc/index.html
% https://cran.r-project.org/web/packages/fansi/index.html
% https://cran.r-project.org/web/packages/filesstrings/index.html
% https://cran.r-project.org/web/packages/fuzzywuzzyR/index.html
% https://cran.r-project.org/web/packages/glue/index.html
% https://cran.r-project.org/web/packages/GrpString/index.html
% https://cran.r-project.org/web/packages/gsubfn/index.html
% https://cran.r-project.org/web/packages/mgsub/index.html
% https://cran.r-project.org/web/packages/rprintf/index.html
% and of course
% https://cran.r-project.org/web/packages/stringr/index.html






\paragraph{Future of \pkg{stringi}.}
Over the years, many useful \proglang{R} packages related
to text processing have been developed, see \citep{textminingr,textr}
for some reviews.
Several of them are listed in the CRAN Task View
on Natural Language Processing\footnote{
See \url{%
https://cran.r-project.org/web/views/NaturalLanguageProcessing.html}.
}.
At the time of the writing of this paper,
\pkg{stringi} itself had over 200 strong (direct) reverse dependencies
and has established itself as one of the most frequently downloaded
\proglang{R} extension. Its user base is growing steadily.

Most importantly, the package can be relied upon by other software projects
as its API is considered stable and most changes are backward compatible.

Future work will involve the porting of \pkg{stringi} to different
scientific/statistical computing environments, including
\proglang{Julia} and \proglang{Python}
with the \pkg{NumPy} \citep{numpy} ecosystem,
offering more Unicode-aware alternatives to the vectorised text processing
facilities from \code{numpy.char} and \pkg{pandas} \citep[Chap.~7]{pandas}.
% PyICU

Moreover, further extensions of \pkg{stringi} shall be conveyed
in order to provide an even broader coverage of \pkg{ICU} services.
% including number and message formatting



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section*{Acknowledgements}

\pkg{stringi} is an open source project
distributed under the terms of the BSD-3-clause license.
Its most recent development snapshot is available through GitHub at
\url{https://github.com/gagolews/stringi}. The bug- and feature request
tracker can be accessed from
\url{https://github.com/gagolews/stringi/issues}.
Moreover, its homepage -- which includes a reference manual
documents the package's API in detail --
is located at \url{https://stringi.gagolewski.com/}.

The author wishes to thank Hadley Wickham for coming
up with the original \pkg{stringr} package API (see Table~\ref{Tab:oldstringr}).
Also, greatly appreciated are the contributions of all who have donated their
time and effort (in all the possible forms: code, feature suggestions,
ideas, criticism, testing) to make \pkg{stringi} better --
Bartek Tartanus,
Kenneth Benoit,
Marcin Bujarski,
Bill Denney,
Katrin Leinweber,
Jeroen Ooms,
Davis Vaughan,
and many others,
see \url{https://github.com/gagolews/stringi/graphs/contributors}.
More contributions are always welcome.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% -- Bibliography -------------------------------------------------------------
%% - References need to be provided in a .bib BibTeX database.
%% - All references should be made with \cite, \citet, \citep, \citealp etc.
%%   (and never hard-coded). See the FAQ for details.
%% - JSS-specific markup (\proglang, \pkg, \code) should be used in the .bib.
%% - Titles in the .bib should be in title case.
%% - DOIs should be included where available.

\begin{thebibliography}{35}
\newcommand{\enquote}[1]{``#1''}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi:\discretionary{}{}{}#1}\else
  \providecommand{\doi}{doi:\discretionary{}{}{}\begingroup
  \urlstyle{rm}\Url}\fi
\providecommand{\eprint}[2][]{\url{#2}}

\bibitem[{Chambers(2008)}]{Chambers2008:SoftDA}
Chambers J (2008).
\newblock \emph{Software for Data Analysis. {P}rogramming with~\proglang{R}}.
\newblock Springer-Verlag.

\bibitem[{Clayden(2019)}]{ore}
Clayden J (2019).
\newblock \emph{\pkg{ore}: {A}n \proglang{R} Interface to the \pkg{Onigmo}
  Regular Expression Library}.
\newblock R package version 1.6.3,
  \urlprefix\url{https://CRAN.R-project.org/package=ore}.

\bibitem[{Crochemore and Rytter(2003)}]{stringology}
Crochemore M, Rytter W (2003).
\newblock \emph{Jewels of Stringology. {T}ext Algorithms}.
\newblock World Scientific.

\bibitem[{Dasu and Johnson(2003)}]{datacleaning}
Dasu T, Johnson T (2003).
\newblock \emph{Exploratory Data Mining and Data Cleaning}.
\newblock John Wiley \& Sons.

\bibitem[{Davis and Chapman(2021)}]{usa29:segmentation}
Davis M, Chapman C (2021).
\newblock \enquote{Unicode Standard Annex \#29: Unicode Text Segmentation.}
\newblock \urlprefix\url{https://unicode.org/reports/tr29/}.

\bibitem[{Davis and Heninger(2021)}]{uts18:regex}
Davis M, Heninger A (2021).
\newblock \enquote{Unicode Technical Standard \#18: Unicode Regular
  Expressions.}
\newblock \urlprefix\url{https://www.unicode.org/reports/tr18/}.

\bibitem[{Davis and Whistler(2021)}]{usa15:normalization}
Davis M, Whistler K (2021).
\newblock \enquote{Unicode Standard Annex \#15: Unicode Normalization Forms.}
\newblock \urlprefix\url{https://www.unicode.org/reports/tr15/}.

\bibitem[{Davis \emph{et~al.}(2021)Davis, Whistler, and
  Scherer}]{uts10:collation}
Davis M, Whistler K, Scherer M (2021).
\newblock \enquote{Unicode Technical Standard \#10: Unicode Collation
  Algorithm.}
\newblock \urlprefix\url{https://www.unicode.org/reports/tr10/}.

\bibitem[{Eddelbuettel(2013)}]{rcppbook}
Eddelbuettel D (2013).
\newblock \emph{Seamless \proglang{R} and \proglang{C++} Integration with
  \pkg{Rcpp}}.
\newblock Springer-Verlag, New York.

\bibitem[{Feinerer \emph{et~al.}(2008)Feinerer, Hornik, and
  Meyer}]{textminingr}
Feinerer I, Hornik K, Meyer D (2008).
\newblock \enquote{Text Mining Infrastructure in \proglang{R}.}
\newblock \emph{Journal of Statistical Software}, \textbf{25}(5), 1--54.

\bibitem[{Friedl(2006)}]{friedl}
Friedl J (2006).
\newblock \emph{Mastering Regular Expressions}.
\newblock O'Reilly.

\bibitem[{Gagolewski(2021)}]{stringx}
Gagolewski M (2021).
\newblock \emph{\pkg{stringx}: {D}rop-in Replacements for Base \proglang{R}
  String Functions Powered by \pkg{stringi}}.
\newblock R package version 0.1.1,
  \urlprefix\url{https://stringx.gagolewski.com/}.

\bibitem[{Hocking(2019)}]{namedCapture}
Hocking TD (2019).
\newblock \enquote{Comparing \pkg{namedCapture} with Other \proglang{R}
  Packages for Regular Expressions.}
\newblock \emph{The \proglang{R} Journal}, \textbf{11/2}, 328--346.

\bibitem[{Hopcroft and Ullman(1979)}]{hopcroftullman}
Hopcroft JE, Ullman JD (1979).
\newblock \emph{Introduction to Automata Theory, Languages, and Computation}.
\newblock Addison-Wesley.

\bibitem[{Jurafsky and Martin(2008)}]{speechlangproc}
Jurafsky D, Martin JH (2008).
\newblock \emph{Speech and Language Processing}.
\newblock Prentice Hall.

\bibitem[{Kleene(1951)}]{kleene}
Kleene SC (1951).
\newblock \enquote{Representation of Events in Nerve Nets and Finite Automata.}
\newblock \emph{Technical Report RM-704}, The RAND Corporation, Santa Monica,
  CA.
\newblock URL
  \url{https://www.rand.org/content/dam/rand/pubs/research_memoranda/2008/RM704.pdf}.

\bibitem[{Knuth \emph{et~al.}(1977)Knuth, Morris, and
  Pratt}]{KnuthETAL1977:kmp}
Knuth D, Morris JH, Pratt V (1977).
\newblock \enquote{Fast Pattern Matching in Strings.}
\newblock \emph{SIAM Journal on Computing}, \textbf{6}(2), 323--350.

\bibitem[{Knuth and Plass(1981)}]{Knuth:wrap}
Knuth D, Plass M (1981).
\newblock \enquote{Breaking Paragraphs into Lines.}
\newblock \emph{Software: Practice and Experience}, \textbf{11}, 1119--1184.

\bibitem[{Kurtz \emph{et~al.}(2004)}]{genome}
Kurtz S, \emph{et~al.} (2004).
\newblock \enquote{Versatile and Open Software for Comparing Large Genomes.}
\newblock \emph{Genome Biology}, \textbf{5}, R12.

\bibitem[{McKinney(2017)}]{pandas}
McKinney W (2017).
\newblock \emph{\proglang{Python} for Data Analysis}.
\newblock O'Reilly.

\bibitem[{Rabin and Scott(1959)}]{automata}
Rabin M, Scott D (1959).
\newblock \enquote{Finite Automata and Their Decision Problems.}
\newblock \emph{IBM Journal of Research and Development}, \textbf{3}, 114--125.

\bibitem[{{\proglang{R} Development Core Team}(2021)}]{Rproject:home}
{\proglang{R} Development Core Team} (2021).
\newblock \emph{\proglang{R}: {A}~Language and Environment for Statistical
  Computing}.
\newblock \proglang{R} Foundation for Statistical Computing, Vienna, Austria.
\newblock \url{https://www.R-project.org}.

\bibitem[{Ritchie and Thompson(1970)}]{qed}
Ritchie DM, Thompson KL (1970).
\newblock \enquote{\pkg{QED} Text Editor.}
\newblock \emph{Technical Report 70107-002}, Bell Telephone Laboratories, Inc.
\newblock
  \urlprefix\url{https://wayback.archive-it.org/all/20150203071645/http://cm.bell-labs.com/cm/cs/who/dmr/qedman.pdf}.

\bibitem[{Szpankowski(2001)}]{szpankowski}
Szpankowski W (2001).
\newblock \emph{Average Case Analysis of Algorithms on Sequences}.
\newblock John Wiley \& Sons.

\bibitem[{{van der Loo}(2014)}]{stringdist}
{van der Loo} M (2014).
\newblock \enquote{The \pkg{stringdist} Package for Approximate String
  Matching.}
\newblock \emph{The \proglang{R} Journal}, \textbf{6}(1), 111--122.

\bibitem[{{van der Loo} and {de Jonge}(2018)}]{cleanr}
{van der Loo} M, {de Jonge} E (2018).
\newblock \emph{Statistical Data Cleaning with Applications in \proglang{R}}.
\newblock John~Wiley \& Sons.

\bibitem[{{van der Walt} \emph{et~al.}(2011){van der Walt}, {Colbert}, and
  {Varoquaux}}]{numpy}
{van der Walt} S, {Colbert} SC, {Varoquaux} G (2011).
\newblock \enquote{The \pkg{NumPy} Array: {A} Structure for Efficient Numerical
  Computation.}
\newblock \emph{Computing in Science Engineering}, \textbf{13}(2), 22--30.

\bibitem[{Welbers \emph{et~al.}(2017)Welbers, {Van Atteveldt}, and
  Benoit}]{textr}
Welbers K, {Van Atteveldt} W, Benoit K (2017).
\newblock \enquote{Text Analysis in \proglang{R}.}
\newblock \emph{Communication Methods and Measures}, \textbf{11}(4), 245--265.

\bibitem[{Wenfeng(2020)}]{re2r}
Wenfeng Q (2020).
\newblock \emph{\pkg{re2r}: \pkg{RE2} Regular Expression}.
\newblock R package version 1.0.0,
  \urlprefix\url{https://github.com/qinwf/re2r}.

\bibitem[{Whistler and Iancu(2021)}]{usa44:ucd}
Whistler K, Iancu L (2021).
\newblock \enquote{Unicode Standard Annex \#44: Unicode Character Database.}
\newblock \urlprefix\url{https://unicode.org/reports/tr44/}.

\bibitem[{Wickham(2010)}]{Wickham2010:stringr}
Wickham H (2010).
\newblock \enquote{\pkg{stringr}: {M}odern, Consistent String Processing.}
\newblock \emph{The \proglang{R} Journal}, \textbf{2}(2), 38--40.

\bibitem[{Wickham(2021)}]{rvest}
Wickham H (2021).
\newblock \emph{\pkg{rvest}: {E}asily Harvest (Scrape) Web Pages}.
\newblock R package version 1.0.0,
  \urlprefix\url{https://CRAN.R-project.org/package=rvest}.

\bibitem[{Wickham and Grolemund(2017)}]{GrolemundWickham2017:rdatascience}
Wickham H, Grolemund G (2017).
\newblock \emph{\proglang{R} for Data Science}.
\newblock O'Reilly.

\bibitem[{Wickham \emph{et~al.}(2020)Wickham, Hester, and Ooms}]{xml2}
Wickham H, Hester J, Ooms J (2020).
\newblock \emph{\pkg{xml2}: {P}arse \proglang{XML}}.
\newblock R package version 1.3.2,
  \urlprefix\url{https://CRAN.R-project.org/package=xml2}.

\bibitem[{Xie(2015)}]{knitr}
Xie Y (2015).
\newblock \emph{Dynamic Documents with \proglang{R} and \pkg{knitr}}.
\newblock Chapman and Hall/CRC.

\end{thebibliography}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\begin{table}[p!]
\centering

\begin{tabularx}{1.0\linewidth}{p{3.4cm}p{3.7cm}X}
\toprule
\pkg{stringr} 0.6.2                            & \bfseries Base \proglang{R} 4.1           & \bfseries Purpose \\
\midrule
\code{str\_c()}                                & \code{paste()}, \code{paste0()}, also \code{sprintf()}                          & join strings \\                                                          \midrule
\code{str\_count()}                            & \code{gregexpr()}                      & count pattern matches\\                                                  \midrule
\code{str\_detect()}                           & \code{grepl()}                         & detect pattern matches \\                                                \midrule
\code{str\_dup()}                              & \code{strrep()}                        & duplicate strings\\                                                      \midrule
\code{str\_extract()}, \code{str\_extract\_all()} & \code{regmatches()} with \code{regexpr()}, \code{gregexpr()}                                      & extract (first, all) pattern matches  \\                                 \midrule
\code{str\_length()}                           & \code{nchar()}                         & compute string length \\                                                 \midrule
                                               & \code{nchar(type="width")}             & compute string width \\                                                 \midrule
\code{str\_locate()}, \code{str\_locate\_all()}& \code{regexpr()}, \code{gregexpr()}    & locate (first, all) pattern matches \\                                   \midrule
\code{str\_match()}, \code{str\_match\_all()}  & \code{regmatches()} with \code{regexec()}, \code{gregexec()}    & extract (first, all) matches to regex capture groups \\                  \midrule
\code{str\_pad()}                              &                                        & add whitespaces at beginning or end\\                                    \midrule
\code{str\_replace()}, \code{str\_replace\_all()}   & \code{sub()}, \code{gsub()}       & replace (first, all) pattern matches with a replacement string\\        \midrule
\code{str\_split()}, \code{str\_split\_fixed()}& \code{strsplit()}                      & split up a string into  pieces \\                       \midrule
\code{str\_sub()}    & \code{substr()}, \code{substring()}                     & extract or replace substrings\\                                         \midrule
\code{str\_trim()}                             & \code{trimws()}                        & remove whitespaces from beginning or end \\                              \midrule
\code{str\_wrap()}                             & \code{strwrap()}                       & split strings into text lines \\                                         \midrule
\code{word()}                                  &                                        & extract words from a sentence \\  \midrule
                                               & \code{startsWith()}, \code{endsWith()} & determine if strings start or end with a pattern match \\ \midrule
                                               & \code{tolower()}, \code{toupper()}     & case mapping and folding \\ \midrule
                                               & \code{chartr()}                        & transliteration \\ \midrule
                                               & \code{sprintf()}                       & string formatting \\ \midrule
                                               & \code{strftime()}, \code{strptime()}   & date-time formatting and parsing \\
\bottomrule
\end{tabularx}

\caption{\label{Tab:oldstringr} Functions in (the historical)
\pkg{stringr} 0.6.2 and their counterparts in base \proglang{R} 4.1.}
\end{table}


\end{document}
